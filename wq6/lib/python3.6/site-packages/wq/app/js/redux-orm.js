define(['exports'], function (exports) { 'use strict';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var _typeof_1 = createCommonjsModule(function (module) {
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;
});

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var createClass = _createClass;

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

var arrayWithoutHoles = _arrayWithoutHoles;

function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

var iterableToArray = _iterableToArray;

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

var nonIterableSpread = _nonIterableSpread;

function _toConsumableArray(arr) {
  return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
}

var toConsumableArray = _toConsumableArray;

/**
 * A special placeholder value used to specify "gaps" within curried functions,
 * allowing partial application of any combination of arguments, regardless of
 * their positions.
 *
 * If `g` is a curried ternary function and `_` is `R.__`, the following are
 * equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2, _)(1, 3)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @name __
 * @constant
 * @memberOf R
 * @since v0.6.0
 * @category Function
 * @example
 *
 *      const greet = R.replace('{name}', R.__, 'Hello, {name}!');
 *      greet('Alice'); //=> 'Hello, Alice!'
 */
var placeholder = { '@@functional/placeholder': true };

function _isPlaceholder(a) {
       return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
}

/**
 * Optimized internal one-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0 || _isPlaceholder(a)) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
}

/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curry2(fn) {
  return function f2(a, b) {
    switch (arguments.length) {
      case 0:
        return f2;
      case 1:
        return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
          return fn(a, _b);
        });
      default:
        return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
          return fn(_a, b);
        }) : _isPlaceholder(b) ? _curry1(function (_b) {
          return fn(a, _b);
        }) : fn(a, b);
    }
  };
}

function _arity(n, fn) {
  /* eslint-disable no-unused-vars */
  switch (n) {
    case 0:
      return function () {
        return fn.apply(this, arguments);
      };
    case 1:
      return function (a0) {
        return fn.apply(this, arguments);
      };
    case 2:
      return function (a0, a1) {
        return fn.apply(this, arguments);
      };
    case 3:
      return function (a0, a1, a2) {
        return fn.apply(this, arguments);
      };
    case 4:
      return function (a0, a1, a2, a3) {
        return fn.apply(this, arguments);
      };
    case 5:
      return function (a0, a1, a2, a3, a4) {
        return fn.apply(this, arguments);
      };
    case 6:
      return function (a0, a1, a2, a3, a4, a5) {
        return fn.apply(this, arguments);
      };
    case 7:
      return function (a0, a1, a2, a3, a4, a5, a6) {
        return fn.apply(this, arguments);
      };
    case 8:
      return function (a0, a1, a2, a3, a4, a5, a6, a7) {
        return fn.apply(this, arguments);
      };
    case 9:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
        return fn.apply(this, arguments);
      };
    case 10:
      return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
        return fn.apply(this, arguments);
      };
    default:
      throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
  }
}

/**
 * Internal curryN function.
 *
 * @private
 * @category Function
 * @param {Number} length The arity of the curried function.
 * @param {Array} received An array of arguments received thus far.
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
function _curryN(length, received, fn) {
  return function () {
    var combined = [];
    var argsIdx = 0;
    var left = length;
    var combinedIdx = 0;
    while (combinedIdx < received.length || argsIdx < arguments.length) {
      var result;
      if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
        result = received[combinedIdx];
      } else {
        result = arguments[argsIdx];
        argsIdx += 1;
      }
      combined[combinedIdx] = result;
      if (!_isPlaceholder(result)) {
        left -= 1;
      }
      combinedIdx += 1;
    }
    return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
  };
}

/**
 * Returns a curried equivalent of the provided function, with the specified
 * arity. The curried function has two unusual capabilities. First, its
 * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.5.0
 * @category Function
 * @sig Number -> (* -> a) -> (* -> a)
 * @param {Number} length The arity for the returned function.
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curry
 * @example
 *
 *      const sumArgs = (...args) => R.sum(args);
 *
 *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */
var curryN = /*#__PURE__*/_curry2(function curryN(length, fn) {
  if (length === 1) {
    return _curry1(fn);
  }
  return _arity(length, _curryN(length, [], fn));
});

/**
 * Returns a curried equivalent of the provided function. The curried function
 * has two unusual capabilities. First, its arguments needn't be provided one
 * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
 * following are equivalent:
 *
 *   - `g(1)(2)(3)`
 *   - `g(1)(2, 3)`
 *   - `g(1, 2)(3)`
 *   - `g(1, 2, 3)`
 *
 * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
 * "gaps", allowing partial application of any combination of arguments,
 * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
 * the following are equivalent:
 *
 *   - `g(1, 2, 3)`
 *   - `g(_, 2, 3)(1)`
 *   - `g(_, _, 3)(1)(2)`
 *   - `g(_, _, 3)(1, 2)`
 *   - `g(_, 2)(1)(3)`
 *   - `g(_, 2)(1, 3)`
 *   - `g(_, 2)(_, 3)(1)`
 *
 * @func
 * @memberOf R
 * @since v0.1.0
 * @category Function
 * @sig (* -> a) -> (* -> a)
 * @param {Function} fn The function to curry.
 * @return {Function} A new, curried function.
 * @see R.curryN, R.partial
 * @example
 *
 *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
 *
 *      const curriedAddFourNumbers = R.curry(addFourNumbers);
 *      const f = curriedAddFourNumbers(1, 2);
 *      const g = f(3);
 *      g(4); //=> 10
 */
var curry = /*#__PURE__*/_curry1(function curry(fn) {
  return curryN(fn.length, fn);
});

function forOwn(obj, fn) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn(obj[key], key);
    }
  }
}

function isArrayLike(value) {
  return value && _typeof_1(value) === 'object' && typeof value.length === 'number' && value.length >= 0 && value.length % 1 === 0;
}

var OWNER_ID_TAG = '@@_______immutableOpsOwnerID';

function fastArrayCopy(arr) {
  var copied = new Array(arr.length);

  for (var i = 0; i < arr.length; i++) {
    copied[i] = arr[i];
  }

  return copied;
}

function canMutate(obj, ownerID) {
  if (!ownerID) return false;
  return obj[OWNER_ID_TAG] === ownerID;
}
var newOwnerID = typeof Symbol === 'function' ? function () {
  return Symbol('ownerID');
} : function () {
  return {};
};
var getBatchToken = newOwnerID;

function addOwnerID(obj, ownerID) {
  Object.defineProperty(obj, OWNER_ID_TAG, {
    value: ownerID,
    configurable: true,
    enumerable: false
  });
  return obj;
}

function prepareNewObject(instance, ownerID) {
  if (ownerID) {
    addOwnerID(instance, ownerID);
  }

  return instance;
}

function forceArray(arg) {
  if (!(arg instanceof Array)) {
    return [arg];
  }

  return arg;
}

var PATH_SEPARATOR = '.';

function normalizePath(pathArg) {
  if (typeof pathArg === 'string') {
    if (pathArg.indexOf(PATH_SEPARATOR) === -1) {
      return [pathArg];
    }

    return pathArg.split(PATH_SEPARATOR);
  }

  return pathArg;
}

function mutableSet(key, value, obj) {
  obj[key] = value;
  return obj;
}

function mutableSetIn(_pathArg, value, obj) {
  var originalPathArg = normalizePath(_pathArg);
  var pathLen = originalPathArg.length;
  var done = false;
  var idx = 0;
  var acc = obj;
  var curr = originalPathArg[idx];

  while (!done) {
    if (idx === pathLen - 1) {
      acc[curr] = value;
      done = true;
    } else {
      var currType = _typeof_1(acc[curr]);

      if (currType === 'undefined') {
        var newObj = {};
        prepareNewObject(newObj, null);
        acc[curr] = newObj;
      } else if (currType !== 'object') {
        var pathRepr = "".concat(originalPathArg[idx - 1], ".").concat(curr);
        throw new Error("A non-object value was encountered when traversing setIn path at ".concat(pathRepr, "."));
      }

      acc = acc[curr];
      idx++;
      curr = originalPathArg[idx];
    }
  }

  return obj;
}

function valueInPath(_pathArg, obj) {
  var pathArg = normalizePath(_pathArg);
  var acc = obj;

  for (var i = 0; i < pathArg.length; i++) {
    var curr = pathArg[i];
    var currRef = acc[curr];

    if (i === pathArg.length - 1) {
      return currRef;
    }

    if (_typeof_1(currRef) === 'object') {
      acc = currRef;
    } else {
      return undefined;
    }
  }

  return undefined;
}

function immutableSetIn(ownerID, _pathArg, value, obj) {
  var pathArg = normalizePath(_pathArg);
  var currentValue = valueInPath(pathArg, obj);
  if (value === currentValue) return obj;
  var pathLen = pathArg.length;
  var acc;

  if (canMutate(obj, ownerID)) {
    acc = obj;
  } else {
    acc = Object.assign(prepareNewObject({}, ownerID), obj);
  }

  var rootObj = acc;
  pathArg.forEach(function (curr, idx) {
    if (idx === pathLen - 1) {
      acc[curr] = value;
      return;
    }

    var currRef = acc[curr];

    var currType = _typeof_1(currRef);

    if (currType === 'object') {
      if (canMutate(currRef, ownerID)) {
        acc = currRef;
      } else {
        var newObj = prepareNewObject({}, ownerID);
        acc[curr] = Object.assign(newObj, currRef);
        acc = newObj;
      }

      return;
    }

    if (currType === 'undefined') {
      var _newObj = prepareNewObject({}, ownerID);

      acc[curr] = _newObj;
      acc = _newObj;
      return;
    }

    var pathRepr = "".concat(pathArg[idx - 1], ".").concat(curr);
    throw new Error("A non-object value was encountered when traversing setIn path at ".concat(pathRepr, "."));
  });
  return rootObj;
}

function mutableMerge(isDeep, _mergeObjs, baseObj) {
  var mergeObjs = forceArray(_mergeObjs);

  if (isDeep) {
    mergeObjs.forEach(function (mergeObj) {
      forOwn(mergeObj, function (value, key) {
        if (isDeep && baseObj.hasOwnProperty(key)) {
          var assignValue;

          if (_typeof_1(value) === 'object') {
            assignValue = mutableMerge(isDeep, [value], baseObj[key]);
          } else {
            assignValue = value;
          }

          baseObj[key] = assignValue;
        } else {
          baseObj[key] = value;
        }
      });
    });
  } else {
    Object.assign.apply(Object, [baseObj].concat(toConsumableArray(mergeObjs)));
  }

  return baseObj;
}

var mutableShallowMerge = mutableMerge.bind(null, false);
var mutableDeepMerge = mutableMerge.bind(null, true);

function mutableOmit(_keys, obj) {
  var keys = forceArray(_keys);
  keys.forEach(function (key) {
    delete obj[key];
  });
  return obj;
}

function shouldMergeKey(obj, other, key) {
  return obj[key] !== other[key];
}

function immutableMerge(isDeep, ownerID, _mergeObjs, obj) {
  if (canMutate(obj, ownerID)) return mutableMerge(isDeep, _mergeObjs, obj);
  var mergeObjs = forceArray(_mergeObjs);
  var hasChanges = false;
  var nextObject = obj;

  var willChange = function willChange() {
    if (!hasChanges) {
      hasChanges = true;
      nextObject = Object.assign({}, obj);
      prepareNewObject(nextObject, ownerID);
    }
  };

  mergeObjs.forEach(function (mergeObj) {
    forOwn(mergeObj, function (mergeValue, key) {
      if (isDeep && obj.hasOwnProperty(key)) {
        var currentValue = nextObject[key];

        if (_typeof_1(mergeValue) === 'object' && !(mergeValue instanceof Array)) {
          if (shouldMergeKey(nextObject, mergeObj, key)) {
            var recursiveMergeResult = immutableMerge(isDeep, ownerID, mergeValue, currentValue);

            if (recursiveMergeResult !== currentValue) {
              willChange();
              nextObject[key] = recursiveMergeResult;
            }
          }

          return true; // continue forOwn
        }
      }

      if (shouldMergeKey(nextObject, mergeObj, key)) {
        willChange();
        nextObject[key] = mergeValue;
      }

      return undefined;
    });
  });
  return nextObject;
}

var immutableDeepMerge = immutableMerge.bind(null, true);
var immutableShallowMerge = immutableMerge.bind(null, false);

function immutableArrSet(ownerID, index, value, arr) {
  if (canMutate(arr, ownerID)) return mutableSet(index, value, arr);
  if (arr[index] === value) return arr;
  var newArr = fastArrayCopy(arr);
  newArr[index] = value;
  prepareNewObject(newArr, ownerID);
  return newArr;
}

function immutableSet(ownerID, key, value, obj) {
  if (isArrayLike(obj)) return immutableArrSet(ownerID, key, value, obj);
  if (canMutate(obj, ownerID)) return mutableSet(key, value, obj);
  if (obj[key] === value) return obj;
  var newObj = Object.assign({}, obj);
  prepareNewObject(newObj, ownerID);
  newObj[key] = value;
  return newObj;
}

function immutableOmit(ownerID, _keys, obj) {
  if (canMutate(obj, ownerID)) return mutableOmit(_keys, obj);
  var keys = forceArray(_keys);
  var keysInObj = keys.filter(function (key) {
    return obj.hasOwnProperty(key);
  }); // None of the keys were in the object, so we can return `obj`.

  if (keysInObj.length === 0) return obj;
  var newObj = Object.assign({}, obj);
  keysInObj.forEach(function (key) {
    delete newObj[key];
  });
  prepareNewObject(newObj, ownerID);
  return newObj;
}

function mutableArrPush(_vals, arr) {
  var vals = forceArray(_vals);
  arr.push.apply(arr, toConsumableArray(vals));
  return arr;
}

function mutableArrFilter(func, arr) {
  var currIndex = 0;
  var originalIndex = 0;

  while (currIndex < arr.length) {
    var item = arr[currIndex];

    if (!func(item, originalIndex)) {
      arr.splice(currIndex, 1);
    } else {
      currIndex++;
    }

    originalIndex++;
  }

  return arr;
}

function mutableArrSplice(index, deleteCount, _vals, arr) {
  var vals = forceArray(_vals);
  arr.splice.apply(arr, [index, deleteCount].concat(toConsumableArray(vals)));
  return arr;
}

function mutableArrInsert(index, _vals, arr) {
  return mutableArrSplice(index, 0, _vals, arr);
}

function immutableArrSplice(ownerID, index, deleteCount, _vals, arr) {
  if (canMutate(arr, ownerID)) return mutableArrSplice(index, deleteCount, _vals, arr);
  var vals = forceArray(_vals);
  var newArr = arr.slice();
  prepareNewObject(newArr, ownerID);
  newArr.splice.apply(newArr, [index, deleteCount].concat(toConsumableArray(vals)));
  return newArr;
}

function immutableArrInsert(ownerID, index, _vals, arr) {
  if (canMutate(arr, ownerID)) return mutableArrInsert(index, _vals, arr);
  return immutableArrSplice(ownerID, index, 0, _vals, arr);
}

function immutableArrPush(ownerID, vals, arr) {
  return immutableArrInsert(ownerID, arr.length, vals, arr);
}

function immutableArrFilter(ownerID, func, arr) {
  if (canMutate(arr, ownerID)) return mutableArrFilter(func, arr);
  var newArr = arr.filter(func);
  if (newArr.length === arr.length) return arr;
  prepareNewObject(newArr, ownerID);
  return newArr;
}

var immutableOperations = {
  // object operations
  merge: immutableShallowMerge,
  deepMerge: immutableDeepMerge,
  omit: immutableOmit,
  setIn: immutableSetIn,
  // array operations
  insert: immutableArrInsert,
  push: immutableArrPush,
  filter: immutableArrFilter,
  splice: immutableArrSplice,
  // both
  set: immutableSet
};
var mutableOperations = {
  // object operations
  merge: mutableShallowMerge,
  deepMerge: mutableDeepMerge,
  omit: mutableOmit,
  setIn: mutableSetIn,
  // array operations
  insert: mutableArrInsert,
  push: mutableArrPush,
  filter: mutableArrFilter,
  splice: mutableArrSplice,
  // both
  set: mutableSet
};
function getImmutableOps() {
  var immutableOps = Object.assign({}, immutableOperations);
  forOwn(immutableOps, function (value, key) {
    immutableOps[key] = curry(value.bind(null, null));
  });
  var mutableOps = Object.assign({}, mutableOperations);
  forOwn(mutableOps, function (value, key) {
    mutableOps[key] = curry(value);
  });
  var batchOps = Object.assign({}, immutableOperations);
  forOwn(batchOps, function (value, key) {
    batchOps[key] = curry(value);
  });

  function batched(_token, _fn) {
    var token;
    var fn;

    if (typeof _token === 'function') {
      fn = _token;
      token = getBatchToken();
    } else {
      token = _token;
      fn = _fn;
    }

    var immutableOpsBoundToToken = Object.assign({}, immutableOperations);
    forOwn(immutableOpsBoundToToken, function (value, key) {
      immutableOpsBoundToToken[key] = curry(value.bind(null, token));
    });
    return fn(immutableOpsBoundToToken);
  }

  return Object.assign(immutableOps, {
    mutable: mutableOps,
    batch: batchOps,
    batched: batched,
    __: placeholder,
    getBatchToken: getBatchToken
  });
}
var ops = getImmutableOps();

var UPDATE = 'REDUX_ORM_UPDATE';
var DELETE = 'REDUX_ORM_DELETE';
var CREATE = 'REDUX_ORM_CREATE';
var FILTER = 'REDUX_ORM_FILTER';
var EXCLUDE = 'REDUX_ORM_EXCLUDE';
var ORDER_BY = 'REDUX_ORM_ORDER_BY';
var SUCCESS = 'SUCCESS';

/**
 * @module utils
 */

function warnDeprecated(msg) {
  var logger = typeof console.warn === 'function' ? console.warn.bind(console) : console.log.bind(console);
  return logger(msg);
}

function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
/**
 * Returns the branch name for a many-to-many relation.
 * The name is the combination of the model name and the field name the relation
 * was declared. The field name's first letter is capitalized.
 *
 * Example: model `Author` has a many-to-many relation to the model `Book`, defined
 * in the `Author` field `books`. The many-to-many branch name will be `AuthorBooks`.
 *
 * @param  {string} declarationModelName - the name of the model the many-to-many relation was declared on
 * @param  {string} fieldName            - the field name where the many-to-many relation was declared on
 * @return {string} The branch name for the many-to-many relation.
 */


function m2mName(declarationModelName, fieldName) {
  return declarationModelName + capitalize(fieldName);
}
/**
 * Returns the fieldname that saves a foreign key to the
 * model id where the many-to-many relation was declared.
 *
 * Example: `Author` => `fromAuthorId`
 *
 * @private
 * @param  {string} declarationModelName - the name of the model where the relation was declared
 * @return {string} the field name in the through model for `declarationModelName`'s foreign key.
 */


function m2mFromFieldName(declarationModelName) {
  return "from".concat(declarationModelName, "Id");
}
/**
 * Returns the fieldname that saves a foreign key in a many-to-many through model to the
 * model where the many-to-many relation was declared.
 *
 * Example: `Book` => `toBookId`
 *
 * @param  {string} otherModelName - the name of the model that was the target of the many-to-many
 *                                   declaration.
 * @return {string} the field name in the through model for `otherModelName`'s foreign key..
 */


function m2mToFieldName(otherModelName) {
  return "to".concat(otherModelName, "Id");
}

function reverseFieldName(modelName) {
  return modelName.toLowerCase() + 'Set'; // eslint-disable-line prefer-template
}

function querySetDelegatorFactory(methodName) {
  return function querySetDelegator() {
    var _this$getQuerySet;

    return (_this$getQuerySet = this.getQuerySet())[methodName].apply(_this$getQuerySet, arguments);
  };
}

function querySetGetterDelegatorFactory(getterName) {
  return function querySetGetterDelegator() {
    var qs = this.getQuerySet();
    return qs[getterName];
  };
}

function forEachSuperClass(subClass, func) {
  var currClass = subClass;

  while (currClass !== Function.prototype) {
    func(currClass);
    currClass = Object.getPrototypeOf(currClass);
  }
}

function attachQuerySetMethods(modelClass, querySetClass) {
  var leftToDefine = querySetClass.sharedMethods.slice(); // There is no way to get a property descriptor for the whole prototype chain;
  // only from an objects own properties. Therefore we traverse the whole prototype
  // chain for querySet.

  forEachSuperClass(querySetClass, function (cls) {
    for (var i = 0; i < leftToDefine.length; i++) {
      var defined = false;
      var methodName = leftToDefine[i];
      var descriptor = Object.getOwnPropertyDescriptor(cls.prototype, methodName);

      if (typeof descriptor !== 'undefined') {
        if (typeof descriptor.get !== 'undefined') {
          descriptor.get = querySetGetterDelegatorFactory(methodName);
          Object.defineProperty(modelClass, methodName, descriptor);
          defined = true;
        } else if (typeof descriptor.value === 'function') {
          modelClass[methodName] = querySetDelegatorFactory(methodName);
          defined = true;
        }
      }

      if (defined) {
        leftToDefine.splice(i--, 1);
      }
    }
  });
}
/**
 * Normalizes `entity` to an id, where `entity` can be an id
 * or a Model instance.
 *
 * @param  {*} entity - either a Model instance or an id value
 * @return {*} the id value of `entity`
 */


function normalizeEntity(entity) {
  if (entity !== null && typeof entity !== 'undefined' && typeof entity.getId === 'function') {
    return entity.getId();
  }

  return entity;
}

function reverseFieldErrorMessage(modelName, fieldName, toModelName, backwardsFieldName) {
  return ["Reverse field ".concat(backwardsFieldName, " already defined"), " on model ".concat(toModelName, ". To fix, set a custom related"), " name on ".concat(modelName, ".").concat(fieldName, ".")].join('');
}

function objectShallowEquals(a, b) {
  var keysInA = 0; // eslint-disable-next-line consistent-return

  Object.entries(Object(a)).forEach(function (_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (!b.hasOwnProperty(key) || b[key] !== value) {
      return false;
    }

    keysInA++;
  });
  return keysInA === Object.keys(b).length;
}

function arrayDiffActions(sourceArr, targetArr) {
  var itemsInBoth = sourceArr.filter(function (item) {
    return targetArr.includes(item);
  });
  var deleteItems = sourceArr.filter(function (item) {
    return !itemsInBoth.includes(item);
  });
  var addItems = targetArr.filter(function (item) {
    return !itemsInBoth.includes(item);
  });

  if (deleteItems.length || addItems.length) {
    return {
      delete: deleteItems,
      add: addItems
    };
  }

  return null;
}

var getBatchToken$1 = ops.getBatchToken;

function clauseFiltersByAttribute(_ref3, attribute) {
  var type = _ref3.type,
      payload = _ref3.payload;
  if (type !== FILTER) return false;

  if (_typeof_1(payload) !== 'object') {
    /**
     * payload could also be a function in which case
     * we would have no way of knowing what it does,
     * so we default to false for non-objects
     */
    return false;
  }

  if (!payload.hasOwnProperty(attribute)) return false;
  var attributeValue = payload[attribute];
  if (attributeValue === null) return false;
  if (attributeValue === undefined) return false;
  return true;
}

function clauseReducesResultSetSize(_ref4) {
  var type = _ref4.type;
  return [FILTER, EXCLUDE].includes(type);
}

function mapValues(object, func) {
  return Object.entries(object).reduce(function (newObject, _ref5) {
    var _ref6 = slicedToArray(_ref5, 2),
        key = _ref6[0],
        value = _ref6[1];

    newObject[key] = func(value);
    return newObject;
  }, {});
}

/**
 * This class is used to build and make queries to the database
 * and operating the resulting set (such as updating attributes
 * or deleting the records).
 *
 * The queries are built lazily. For example:
 *
 * ```javascript
 * const qs = Book.all()
 *     .filter(book => book.releaseYear > 1999)
 *     .orderBy('name');
 * ```
 *
 * Doesn't execute a query. The query is executed only when
 * you need information from the query result, such as {@link QuerySet#count},
 * {@link QuerySet#toRefArray}. After the query is executed, the resulting
 * set is cached in the QuerySet instance.
 *
 * QuerySet instances also return copies, so chaining filters doesn't
 * mutate the previous instances.
 */

var QuerySet =
/*#__PURE__*/
function () {
  /**
   * Creates a QuerySet. The constructor is mainly for internal use;
   * You should access QuerySet instances from {@link Model}.
   *
   * @param  {Model} modelClass - the model class of objects in this QuerySet.
   * @param  {any[]} clauses - query clauses needed to evaluate the set.
   * @param {Object} [opts] - additional options
   */
  function QuerySet(modelClass, clauses, opts) {
    Object.assign(this, {
      modelClass: modelClass,
      clauses: clauses || []
    });
    this._opts = opts;
  }

  QuerySet.addSharedMethod = function addSharedMethod(methodName) {
    this.sharedMethods = this.sharedMethods.concat(methodName);
  };

  var _proto = QuerySet.prototype;

  _proto._new = function _new(clauses, userOpts) {
    var opts = Object.assign({}, this._opts, userOpts);
    return new this.constructor(this.modelClass, clauses, opts);
  };

  _proto.toString = function toString() {
    var _this = this;

    this._evaluate();

    var contents = this.rows.map(function (_ref) {
      var id = _ref.id;
      return _this.modelClass.withId(id).toString();
    }).join('\n    - ');
    return "QuerySet contents:\n    - ".concat(contents);
  }
  /**
   * Returns an array of the plain objects represented by the QuerySet.
   * The plain objects are direct references to the store.
   *
   * @return {Object[]} references to the plain JS objects represented by
   *                    the QuerySet
   */
  ;

  _proto.toRefArray = function toRefArray() {
    return this._evaluate();
  }
  /**
   * Returns an array of {@link Model} instances represented by the QuerySet.
   * @return {Model[]} model instances represented by the QuerySet
   */
  ;

  _proto.toModelArray = function toModelArray() {
    var ModelClass = this.modelClass;
    return this._evaluate().map(function (props) {
      return new ModelClass(props);
    });
  }
  /**
   * Returns the number of {@link Model} instances represented by the QuerySet.
   *
   * @return {number} length of the QuerySet
   */
  ;

  _proto.count = function count() {
    this._evaluate();

    return this.rows.length;
  }
  /**
   * Checks if the {@link QuerySet} instance has any records matching the query
   * in the database.
   *
   * @return {Boolean} `true` if the {@link QuerySet} instance contains entities, else `false`.
   */
  ;

  _proto.exists = function exists() {
    return Boolean(this.count());
  }
  /**
   * Returns the {@link Model} instance at index `index` in the {@link QuerySet} instance if
   * `withRefs` flag is set to `false`, or a reference to the plain JavaScript
   * object in the model state if `true`.
   *
   * @param  {number} index - index of the model instance to get
   * @return {Model|undefined} a {@link Model} instance at index
   *                           `index` in the {@link QuerySet} instance,
   *                           or undefined if the index is out of bounds.
   */
  ;

  _proto.at = function at(index) {
    var ModelClass = this.modelClass;

    var rows = this._evaluate();

    if (index >= 0 && index < rows.length) {
      return new ModelClass(rows[index]);
    }

    return undefined;
  }
  /**
   * Returns the {@link Model} instance at index 0 in the {@link QuerySet} instance.
   * @return {Model}
   */
  ;

  _proto.first = function first() {
    return this.at(0);
  }
  /**
   * Returns the {@link Model} instance at index `QuerySet.count() - 1`
   * @return {Model}
   */
  ;

  _proto.last = function last() {
    var rows = this._evaluate();

    return this.at(rows.length - 1);
  }
  /**
   * Returns a new {@link QuerySet} instance with the same entities.
   * @return {QuerySet} a new QuerySet with the same entities.
   */
  ;

  _proto.all = function all() {
    return this._new(this.clauses);
  }
  /**
   * Returns a new {@link QuerySet} instance with entities that match properties in `lookupObj`.
   *
   * @param  {Object} lookupObj - the properties to match objects with. Can also be a function.
   * @return {QuerySet} a new {@link QuerySet} instance with objects that passed the filter.
   */
  ;

  _proto.filter = function filter(lookupObj) {
    /**
     * allow foreign keys to be specified as model instances,
     * transform model instances to their primary keys
     */
    var normalizedLookupObj = _typeof_1(lookupObj) === 'object' ? mapValues(lookupObj, normalizeEntity) : lookupObj;
    var filterDescriptor = {
      type: FILTER,
      payload: normalizedLookupObj
    };
    /**
     * create a new QuerySet
     * including only rows matching the lookupObj
     */

    return this._new(this.clauses.concat(filterDescriptor));
  }
  /**
   * Returns a new {@link QuerySet} instance with entities that do not match
   * properties in `lookupObj`.
   *
   * @param  {Object} lookupObj - the properties to unmatch objects with. Can also be a function.
   * @return {QuerySet} a new {@link QuerySet} instance with objects that did not pass the filter.
   */
  ;

  _proto.exclude = function exclude(lookupObj) {
    /**
     * allow foreign keys to be specified as model instances,
     * transform model instances to their primary keys
     */
    var normalizedLookupObj = _typeof_1(lookupObj) === 'object' ? mapValues(lookupObj, normalizeEntity) : lookupObj;
    var excludeDescriptor = {
      type: EXCLUDE,
      payload: normalizedLookupObj
    };
    /**
     * create a new QuerySet
     * excluding all rows matching the lookupObj
     */

    return this._new(this.clauses.concat(excludeDescriptor));
  }
  /**
   * Performs the actual database query.
   * @private
   * @return {Array} rows corresponding to the QuerySet's clauses
   */
  ;

  _proto._evaluate = function _evaluate() {
    if (typeof this.modelClass.session === 'undefined') {
      throw new Error(["Tried to query the ".concat(this.modelClass.modelName, " model's table without a session. "), 'Create a session using `session = orm.session()` and use ', "`session[\"".concat(this.modelClass.modelName, "\"]` for querying instead.")].join(''));
    }

    if (!this._evaluated) {
      var _this$modelClass = this.modelClass,
          session = _this$modelClass.session,
          table = _this$modelClass.modelName;
      var querySpec = {
        table: table,
        clauses: this.clauses
      };
      this.rows = session.query(querySpec).rows;
      this._evaluated = true;
    }

    return this.rows;
  }
  /**
   * Returns a new {@link QuerySet} instance with entities ordered by `iteratees` in ascending
   * order, unless otherwise specified. Delegates to `lodash.orderBy`.
   *
   * @param  {string[]|Function[]} iteratees - an array where each item can be a string or a
   *                                           function. If a string is supplied, it should
   *                                           correspond to property on the entity that will
   *                                           determine the order. If a function is supplied,
   *                                           it should return the value to order by.
   * @param {Boolean[]} [orders] - the sort orders of `iteratees`. If unspecified, all iteratees
   *                               will be sorted in ascending order. `true` and `'asc'`
   *                               correspond to ascending order, and `false` and `'desc`
   *                               to descending order.
   * @return {QuerySet} a new {@link QuerySet} with objects ordered by `iteratees`.
   */
  ;

  _proto.orderBy = function orderBy(iteratees, orders) {
    var orderByDescriptor = {
      type: ORDER_BY,
      payload: [iteratees, orders]
    };
    /**
     * create a new QuerySet
     * sorting all rows according to the passed arguments
     */

    return this._new(this.clauses.concat(orderByDescriptor));
  }
  /**
   * Records an update specified with `mergeObj` to all the objects
   * in the {@link QuerySet} instance.
   *
   * @param  {Object} mergeObj - an object to merge with all the objects in this
   *                             queryset.
   * @return {undefined}
   */
  ;

  _proto.update = function update(mergeObj) {
    var _this$modelClass2 = this.modelClass,
        session = _this$modelClass2.session,
        table = _this$modelClass2.modelName;
    session.applyUpdate({
      action: UPDATE,
      query: {
        table: table,
        clauses: this.clauses
      },
      payload: mergeObj
    });
    this._evaluated = false;
  }
  /**
   * Records a deletion of all the objects in this {@link QuerySet} instance.
   * @return {undefined}
   */
  ;

  _proto.delete = function _delete() {
    var _this$modelClass3 = this.modelClass,
        session = _this$modelClass3.session,
        table = _this$modelClass3.modelName;
    this.toModelArray().forEach(function (model) {
      return model._onDelete();
    } // eslint-disable-line no-underscore-dangle
    );
    session.applyUpdate({
      action: DELETE,
      query: {
        table: table,
        clauses: this.clauses
      }
    });
    this._evaluated = false;
  } // DEPRECATED AND REMOVED METHODS

  /**
   * @deprecated
   * Use {@link QuerySet#toModelArray} or predicate functions that
   * instantiate Models from refs, e.g. `new Model(ref)`.
   */
  ;

  /**
   * @deprecated
   * Call {@link QuerySet#toModelArray} or {@link QuerySet#toRefArray} first to map.
   */
  _proto.map = function map() {
    throw new Error('`QuerySet.prototype.map` has been removed. ' + 'Call `.toModelArray()` or `.toRefArray()` first to map.');
  }
  /**
   * @deprecated
   * Call {@link QuerySet#toModelArray} or {@link QuerySet#toRefArray} first to iterate.
   */
  ;

  _proto.forEach = function forEach() {
    throw new Error('`QuerySet.prototype.forEach` has been removed. ' + 'Call `.toModelArray()` or `.toRefArray()` first to iterate.');
  };

  createClass(QuerySet, [{
    key: "withModels",
    get: function get() {
      throw new Error('`QuerySet.prototype.withModels` has been removed. ' + 'Use `.toModelArray()` or predicate functions that ' + 'instantiate Models from refs, e.g. `new Model(ref)`.');
    }
    /**
     * @deprecated Query building operates on refs only now.
     */

  }, {
    key: "withRefs",
    get: function get() {
      warnDeprecated('`QuerySet.prototype.withRefs` has been deprecated. ' + 'Query building operates on refs only now.');
      return undefined;
    }
  }]);

  return QuerySet;
}();

QuerySet.sharedMethods = ['count', 'at', 'all', 'last', 'first', 'filter', 'exclude', 'orderBy', 'update', 'delete'];

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var defineProperty = _defineProperty;

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      defineProperty(target, key, source[key]);
    });
  }

  return target;
}

var objectSpread = _objectSpread;

var Session =
/*#__PURE__*/
function () {
  /**
   * Creates a new Session.
   *
   * @param  {Database} db - a {@link Database} instance
   * @param  {Object} state - the database state
   * @param  {Boolean} [withMutations] - whether the session should mutate data
   * @param  {Object} [batchToken] - used by the backend to identify objects that can be
   *                                 mutated.
   */
  function Session(schema, db, state, withMutations, batchToken) {
    var _this = this;

    this.schema = schema;
    this.db = db;
    this.state = state || db.getEmptyState();
    this.initialState = this.state;
    this.withMutations = Boolean(withMutations);
    this.batchToken = batchToken || getBatchToken();
    this.modelData = {};
    this.models = schema.getModelClasses();
    this.sessionBoundModels = this.models.map(function (modelClass) {
      function SessionBoundModel() {
        return Reflect.construct(modelClass, arguments, SessionBoundModel); // eslint-disable-line prefer-rest-params
      }

      Reflect.setPrototypeOf(SessionBoundModel.prototype, modelClass.prototype);
      Reflect.setPrototypeOf(SessionBoundModel, modelClass);
      Object.defineProperty(_this, modelClass.modelName, {
        get: function get() {
          return SessionBoundModel;
        }
      });
      SessionBoundModel.connect(_this);
      return SessionBoundModel;
    });
  }

  var _proto = Session.prototype;

  _proto.getDataForModel = function getDataForModel(modelName) {
    if (!this.modelData[modelName]) {
      this.modelData[modelName] = {};
    }

    return this.modelData[modelName];
  };

  _proto.markAccessed = function markAccessed(modelName, modelIds) {
    var data = this.getDataForModel(modelName);

    if (!data.accessedInstances) {
      data.accessedInstances = {};
    }

    modelIds.forEach(function (id) {
      data.accessedInstances[id] = true;
    });
  };

  _proto.markFullTableScanned = function markFullTableScanned(modelName) {
    var data = this.getDataForModel(modelName);
    data.fullTableScanned = true;
  };

  _proto.markAccessedIndexes = function markAccessedIndexes(indexes) {
    var _this2 = this;

    indexes.forEach(function (_ref) {
      var _ref2 = slicedToArray(_ref, 3),
          table = _ref2[0],
          attr = _ref2[1],
          value = _ref2[2];

      var data = _this2.getDataForModel(table);

      if (!data.accessedIndexes) {
        data.accessedIndexes = {};
      }

      data.accessedIndexes[attr] = [].concat(toConsumableArray(data.accessedIndexes[attr] || []), [value]);
    });
  };

  /**
   * Applies update to a model state.
   *
   * @private
   * @param {Object} update - the update object. Must have keys
   *                          `type`, `payload`.
   */
  _proto.applyUpdate = function applyUpdate(updateSpec) {
    var tx = this._getTransaction(updateSpec);

    var result = this.db.update(updateSpec, tx, this.state);
    var status = result.status,
        state = result.state,
        payload = result.payload;

    if (status !== SUCCESS) {
      throw new Error("Applying update failed with status ".concat(status, ". Payload: ").concat(payload));
    }

    this.state = state;
    return payload;
  };

  _proto.query = function query(querySpec) {
    var result = this.db.query(querySpec, this.state);

    this._markAccessedByQuery(querySpec, result);

    return result;
  };

  _proto._getTransaction = function _getTransaction(updateSpec) {
    var withMutations = this.withMutations;
    var action = updateSpec.action;
    var batchToken = this.batchToken;

    if ([UPDATE, DELETE].includes(action)) {
      batchToken = getBatchToken();
    }

    return {
      batchToken: batchToken,
      withMutations: withMutations
    };
  };

  _proto._markAccessedByQuery = function _markAccessedByQuery(querySpec, result) {
    var table = querySpec.table,
        clauses = querySpec.clauses;
    var rows = result.rows;
    var idAttribute = this[table].idAttribute;
    var accessedIds = new Set(rows.map(function (row) {
      return row[idAttribute];
    }));
    var anyClauseFilteredByPk = clauses.some(function (clause) {
      if (!clauseFiltersByAttribute(clause, idAttribute)) {
        return false;
      }

      var id = clause.payload[idAttribute];
      if (id === null) return false;
      /**
       * We previously knew which row we wanted to access,
       * so there was no need to scan the entire table.
       */

      accessedIds.add(id);
      return true;
    });
    var accessedIndexes = [];
    var indexes = this.state[table].indexes;
    clauses.forEach(function (clause) {
      Object.keys(indexes).forEach(function (attr) {
        if (!clauseFiltersByAttribute(clause, attr)) return;
        var value = clause.payload[attr];
        accessedIndexes.push([table, attr, value]);
      });
    });

    if (anyClauseFilteredByPk) {
      /**
       * The clauses have been ordered so that an indexed one was
       * the first to have been evaluated, and thus only the row
       * with the specified PK value has actually been accessed.
       */
      this.markAccessed(table, accessedIds);
    } else if (accessedIndexes.length) {
      /**
       * At least one clause was optimized using indexes.
       */
      this.markAccessed(table, accessedIds);
      this.markAccessedIndexes(accessedIndexes);
    } else {
      /**
       * At least one clause could not be efficiently optimized
       * or no clause was specified at all.
       */
      this.markFullTableScanned(table);
    }
  } // DEPRECATED AND REMOVED METHODS

  /**
   * @deprecated Access {@link Session#state} instead.
   */
  ;

  _proto.getNextState = function getNextState() {
    warnDeprecated('`Session.prototype.getNextState` has been deprecated. Access ' + 'the `Session.prototype.state` property instead.');
    return this.state;
  }
  /**
   * @deprecated
   * The Redux integration API is now decoupled from ORM and Session.<br>
   * See the 0.9 migration guide in the GitHub repo.
   */
  ;

  _proto.reduce = function reduce() {
    throw new Error('`Session.prototype.reduce` has been removed. The Redux integration API ' + 'is now decoupled from ORM and Session - see the 0.9 migration guide ' + 'in the GitHub repo.');
  };

  createClass(Session, [{
    key: "accessedModelInstances",
    get: function get() {
      var _this3 = this;

      return this.sessionBoundModels.filter(function (_ref3) {
        var modelName = _ref3.modelName;
        return _this3.getDataForModel(modelName).accessedInstances;
      }).reduce(function (result, _ref4) {
        var modelName = _ref4.modelName;
        return objectSpread({}, result, defineProperty({}, modelName, _this3.getDataForModel(modelName).accessedInstances));
      }, {});
    }
  }, {
    key: "fullTableScannedModels",
    get: function get() {
      var _this4 = this;

      return this.sessionBoundModels.filter(function (_ref5) {
        var modelName = _ref5.modelName;
        return _this4.getDataForModel(modelName).fullTableScanned;
      }).map(function (_ref6) {
        var modelName = _ref6.modelName;
        return modelName;
      });
    }
  }, {
    key: "accessedIndexes",
    get: function get() {
      var _this5 = this;

      return this.sessionBoundModels.filter(function (_ref7) {
        var modelName = _ref7.modelName;
        return _this5.getDataForModel(modelName).accessedIndexes;
      }).reduce(function (result, _ref8) {
        var modelName = _ref8.modelName;
        return objectSpread({}, result, defineProperty({}, modelName, _this5.getDataForModel(modelName).accessedIndexes));
      }, {});
    }
  }]);

  return Session;
}();

var setPrototypeOf = createCommonjsModule(function (module) {
function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;
});

var construct = createCommonjsModule(function (module) {
function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    module.exports = _construct = Reflect.construct;
  } else {
    module.exports = _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

module.exports = _construct;
});

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var inheritsLoose = _inheritsLoose;

/**
 * The functions in this file return custom JS property descriptors
 * that are supposed to be assigned to Model fields.
 *
 * Some include the logic to look up models using foreign keys and
 * to add or remove relationships between models.
 *
 * @module descriptors
 */

/**
 * Defines a basic non-key attribute.
 * @param  {string} fieldName - the name of the field the descriptor will be assigned to.
 */

function attrDescriptor(fieldName) {
  return {
    get: function get() {
      return this._fields[fieldName];
    },
    set: function set(value) {
      return this.set(fieldName, value);
    },
    enumerable: true,
    configurable: true
  };
}
/**
 * Forwards direction of a Foreign Key: returns one object.
 * Also works as {@link .forwardsOneToOneDescriptor|forwardsOneToOneDescriptor}.
 *
 * For `book.author` referencing an `Author` model instance,
 * `fieldName` would be `'author'` and `declaredToModelName` would be `'Author'`.
 * @param  {string} fieldName - the name of the field the descriptor will be assigned to.
 * @param  {string} declaredToModelName - the name of the model that the field references.
 */


function forwardsManyToOneDescriptor(fieldName, declaredToModelName) {
  return {
    get: function get() {
      var _this$getClass = this.getClass(),
          DeclaredToModel = _this$getClass.session[declaredToModelName];

      var toId = this._fields[fieldName];
      return DeclaredToModel.withId(toId);
    },
    set: function set(value) {
      this.update(defineProperty({}, fieldName, normalizeEntity(value)));
    }
  };
}
/**
 * Dereferencing foreign keys in {@link module:fields.oneToOne|oneToOne}
 * relationships works the same way as in many-to-one relationships:
 * just look up the related model.
 *
 * For example, a human face tends to have a single nose.
 * So if we want to resolve `face.nose`, we need to
 * look up the `Nose` that has the primary key that `face` references.
 *
 * @see {@link module:descriptors~forwardsManyToOneDescriptor|forwardsManyToOneDescriptor}
 */


function forwardsOneToOneDescriptor() {
  return forwardsManyToOneDescriptor.apply(void 0, arguments);
}
/**
 * Here we resolve 1-to-1 relationships starting at the model on which the
 * field was not installed. This means we need to find the instance of the
 * other model whose {@link module:fields.oneToOne|oneToOne} FK field contains the current model's primary key.
 *
 * @param  {string} declaredFieldName - the name of the field referencing the current model.
 * @param  {string} declaredFromModelName - the name of the other model.
 */


function backwardsOneToOneDescriptor(declaredFieldName, declaredFromModelName) {
  return {
    get: function get() {
      var _this$getClass2 = this.getClass(),
          DeclaredFromModel = _this$getClass2.session[declaredFromModelName];

      return DeclaredFromModel.get(defineProperty({}, declaredFieldName, this.getId()));
    },
    set: function set() {
      throw new Error('Can\'t mutate a reverse one-to-one relation.');
    }
  };
}
/**
 * The backwards direction of a n-to-1 relationship (i.e. 1-to-n),
 * meaning this will return an a collection (`QuerySet`) of model instances.
 *
 * An example would be `author.books` referencing all instances of
 * the `Book` model that reference the author using `fk()`.
 */


function backwardsManyToOneDescriptor(declaredFieldName, declaredFromModelName) {
  return {
    get: function get() {
      var _this$getClass3 = this.getClass(),
          DeclaredFromModel = _this$getClass3.session[declaredFromModelName];

      return DeclaredFromModel.filter(defineProperty({}, declaredFieldName, this.getId()));
    },
    set: function set() {
      throw new Error('Can\'t mutate a reverse many-to-one relation.');
    }
  };
}
/**
 * This descriptor is assigned to both sides of a many-to-many relationship.
 * To indicate the backwards direction pass `true` for `reverse`.
 */


function manyToManyDescriptor(declaredFromModelName, declaredToModelName, throughModelName, throughFields, reverse) {
  return {
    get: function get() {
      var _this$getClass4 = this.getClass(),
          _this$getClass4$sessi = _this$getClass4.session,
          DeclaredFromModel = _this$getClass4$sessi[declaredFromModelName],
          DeclaredToModel = _this$getClass4$sessi[declaredToModelName],
          ThroughModel = _this$getClass4$sessi[throughModelName];

      var ThisModel = reverse ? DeclaredToModel : DeclaredFromModel;
      var OtherModel = reverse ? DeclaredFromModel : DeclaredToModel;
      var thisReferencingField = reverse ? throughFields.to : throughFields.from;
      var otherReferencingField = reverse ? throughFields.from : throughFields.to;
      var thisId = this.getId();
      var throughQs = ThroughModel.filter(defineProperty({}, thisReferencingField, thisId));
      /**
       * all IDs of instances of the other model that are
       * referenced by any instance of the current model
       */

      var referencedOtherIds = new Set(throughQs.toRefArray().map(function (obj) {
        return obj[otherReferencingField];
      }));
      /**
       * selects all instances of other model that are referenced
       * by any instance of the current model
       */

      var qs = OtherModel.filter(function (otherModelInstance) {
        return referencedOtherIds.has(otherModelInstance[OtherModel.idAttribute]);
      });
      /**
       * Allows adding OtherModel instances to be referenced by the current instance.
       *
       * E.g. Book.first().authors.add(1, 2) would add the authors with IDs 1 and 2
       * to the first book's list of referenced authors.
       *
       * @return undefined
       */

      qs.add = function add() {
        for (var _len = arguments.length, entities = new Array(_len), _key = 0; _key < _len; _key++) {
          entities[_key] = arguments[_key];
        }

        var idsToAdd = new Set(entities.map(normalizeEntity));
        var existingQs = throughQs.filter(function (through) {
          return idsToAdd.has(through[otherReferencingField]);
        });

        if (existingQs.exists()) {
          var existingIds = existingQs.toRefArray().map(function (through) {
            return through[otherReferencingField];
          });
          throw new Error("Tried to add already existing ".concat(OtherModel.modelName, " id(s) ").concat(existingIds, " to the ").concat(ThisModel.modelName, " instance with id ").concat(thisId));
        }

        idsToAdd.forEach(function (id) {
          var _ThroughModel$create;

          ThroughModel.create((_ThroughModel$create = {}, defineProperty(_ThroughModel$create, otherReferencingField, id), defineProperty(_ThroughModel$create, thisReferencingField, thisId), _ThroughModel$create));
        });
      };
      /**
       * Removes references to all OtherModel instances from the current model.
       *
       * E.g. Book.first().authors.clear() would cause the first book's list
       * of referenced authors to become empty.
       *
       * @return undefined
       */


      qs.clear = function clear() {
        throughQs.delete();
      };
      /**
       * Removes references to all passed OtherModel instances from the current model.
       *
       * E.g. Book.first().authors.remove(1, 2) would cause the authors with
       * IDs 1 and 2 to no longer be referenced by the first book.
       *
       * @return undefined
       */


      qs.remove = function remove() {
        for (var _len2 = arguments.length, entities = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          entities[_key2] = arguments[_key2];
        }

        var idsToRemove = new Set(entities.map(normalizeEntity));
        var entitiesToDelete = throughQs.filter(function (through) {
          return idsToRemove.has(through[otherReferencingField]);
        });

        if (entitiesToDelete.count() !== idsToRemove.size) {
          // Tried deleting non-existing entities.
          var entitiesToDeleteIds = entitiesToDelete.toRefArray().map(function (through) {
            return through[otherReferencingField];
          });

          var unexistingIds = toConsumableArray(idsToRemove).filter(function (id) {
            return !entitiesToDeleteIds.includes(id);
          });

          throw new Error("Tried to delete non-existing ".concat(OtherModel.modelName, " id(s) ").concat(unexistingIds, " from the ").concat(ThisModel.modelName, " instance with id ").concat(thisId));
        }

        entitiesToDelete.delete();
      };

      return qs;
    },
    set: function set() {
      throw new Error('Tried setting a M2M field. Please use the related QuerySet methods add, remove and clear.');
    }
  };
}

/**
 * Contains the logic for how fields on {@link Model}s work
 * and which descriptors must be installed.
 *
 * If your goal is to define fields on a Model class,
 * please use the more convenient methods {@link attr},
 * {@link fk}, {@link many} and {@link oneToOne}.
 *
 * @module fields
 */

/**
 * Defines algorithm for installing a field onto a model and related models.
 * Conforms to the template method behavioral design pattern.
 * @private
 */

var FieldInstallerTemplate =
/*#__PURE__*/
function () {
  function FieldInstallerTemplate(opts) {
    this.field = opts.field;
    this.fieldName = opts.fieldName;
    this.model = opts.model;
    this.orm = opts.orm;
    /**
     * the field itself has no knowledge of the model
     * it is being installed upon; we need to inform it
     * that it is a self-referencing field for the field
     * to be able to make better informed decisions
     */

    if (this.field.references(this.model)) {
      this.field.toModelName = 'this';
    }
  }

  var _proto = FieldInstallerTemplate.prototype;

  _proto.run = function run() {
    if (this.field.installsForwardsDescriptor) {
      this.installForwardsDescriptor();
    }

    if (this.field.installsForwardsVirtualField) {
      this.installForwardsVirtualField();
    }
    /**
     * Install a backwards field on a model as a consequence
     * of having installed the forwards field on another model.
     */


    if (this.field.installsBackwardsDescriptor) {
      this.installBackwardsDescriptor();
    }

    if (this.field.installsBackwardsVirtualField) {
      this.installBackwardsVirtualField();
    }
  };

  createClass(FieldInstallerTemplate, [{
    key: "toModel",
    get: function get() {
      if (typeof this._toModel === 'undefined') {
        var toModelName = this.field.toModelName;

        if (!toModelName) {
          this._toModel = null;
        } else if (toModelName === 'this') {
          this._toModel = this.model;
        } else {
          this._toModel = this.orm.get(toModelName);
        }
      }

      return this._toModel;
    }
  }, {
    key: "throughModel",
    get: function get() {
      if (typeof this._throughModel === 'undefined') {
        var throughModelName = this.field.getThroughModelName(this.fieldName, this.model);

        if (!throughModelName) {
          this._throughModel = null;
        } else {
          this._throughModel = this.orm.get(throughModelName);
        }
      }

      return this._throughModel;
    }
  }, {
    key: "backwardsFieldName",
    get: function get() {
      return this.field.getBackwardsFieldName(this.model);
    }
  }]);

  return FieldInstallerTemplate;
}();
/**
 * Default implementation for the template method in FieldInstallerTemplate.
 * @private
 */


var DefaultFieldInstaller =
/*#__PURE__*/
function (_FieldInstallerTempla) {
  inheritsLoose(DefaultFieldInstaller, _FieldInstallerTempla);

  function DefaultFieldInstaller() {
    return _FieldInstallerTempla.apply(this, arguments) || this;
  }

  var _proto2 = DefaultFieldInstaller.prototype;

  _proto2.installForwardsDescriptor = function installForwardsDescriptor() {
    Object.defineProperty(this.model.prototype, this.fieldName, this.field.createForwardsDescriptor(this.fieldName, this.model, this.toModel, this.throughModel));
  };

  _proto2.installForwardsVirtualField = function installForwardsVirtualField() {
    this.model.virtualFields[this.fieldName] = this.field.createForwardsVirtualField(this.fieldName, this.model, this.toModel, this.throughModel);
  };

  _proto2.installBackwardsDescriptor = function installBackwardsDescriptor() {
    var backwardsDescriptor = Object.getOwnPropertyDescriptor(this.toModel.prototype, this.backwardsFieldName);

    if (backwardsDescriptor) {
      throw new Error(reverseFieldErrorMessage(this.model.modelName, this.fieldName, this.toModel.modelName, this.backwardsFieldName));
    } // install backwards descriptor


    Object.defineProperty(this.toModel.prototype, this.backwardsFieldName, this.field.createBackwardsDescriptor(this.fieldName, this.model, this.toModel, this.throughModel));
  };

  _proto2.installBackwardsVirtualField = function installBackwardsVirtualField() {
    this.toModel.virtualFields[this.backwardsFieldName] = this.field.createBackwardsVirtualField(this.fieldName, this.model, this.toModel, this.throughModel);
  };

  return DefaultFieldInstaller;
}(FieldInstallerTemplate);
/**
 * @ignore
 */


var Field =
/*#__PURE__*/
function () {
  function Field() {
    this.index = false;
  }

  var _proto3 = Field.prototype;

  _proto3.getClass = function getClass() {
    return this.constructor;
  };

  _proto3.references = function references(model) {
    return false;
  };

  _proto3.getThroughModelName = function getThroughModelName(fieldName, model) {
    return null;
  };

  createClass(Field, [{
    key: "installerClass",
    get: function get() {
      return DefaultFieldInstaller;
    }
  }, {
    key: "installsForwardsDescriptor",
    get: function get() {
      return true;
    }
  }, {
    key: "installsForwardsVirtualField",
    get: function get() {
      return false;
    }
  }, {
    key: "installsBackwardsDescriptor",
    get: function get() {
      return false;
    }
  }, {
    key: "installsBackwardsVirtualField",
    get: function get() {
      return false;
    }
  }]);

  return Field;
}();
/**
 * @ignore
 */


var Attribute =
/*#__PURE__*/
function (_Field) {
  inheritsLoose(Attribute, _Field);

  function Attribute(opts) {
    var _this;

    _this = _Field.call(this) || this;
    _this.opts = opts || {};

    if (_this.opts.hasOwnProperty('getDefault')) {
      _this.getDefault = _this.opts.getDefault;
    }

    return _this;
  }

  var _proto4 = Attribute.prototype;

  _proto4.createForwardsDescriptor = function createForwardsDescriptor(fieldName, model) {
    return attrDescriptor(fieldName);
  };

  return Attribute;
}(Field);
/**
 * @ignore
 */

var RelationalField =
/*#__PURE__*/
function (_Field2) {
  inheritsLoose(RelationalField, _Field2);

  function RelationalField() {
    var _this2;

    _this2 = _Field2.call(this) || this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (args.length === 1 && _typeof_1(args[0]) === 'object') {
      var opts = args[0];
      _this2.toModelName = opts.to;
      _this2.relatedName = opts.relatedName;
      _this2.through = opts.through;
      _this2.throughFields = opts.throughFields;
      _this2.as = opts.as;
    } else {
      _this2.toModelName = args[0];
      _this2.relatedName = args[1];
    }

    return _this2;
  }

  var _proto5 = RelationalField.prototype;

  _proto5.getBackwardsFieldName = function getBackwardsFieldName(model) {
    return this.relatedName || reverseFieldName(model.modelName);
  };

  _proto5.createBackwardsVirtualField = function createBackwardsVirtualField(fieldName, model, toModel, throughModel) {
    var ThisField = this.getClass();
    return new ThisField(model.modelName, fieldName);
  };

  _proto5.references = function references(model) {
    return this.toModelName === model.modelName;
  };

  createClass(RelationalField, [{
    key: "installsBackwardsVirtualField",
    get: function get() {
      return true;
    }
  }, {
    key: "installsBackwardsDescriptor",
    get: function get() {
      return true;
    }
  }, {
    key: "installerClass",
    get: function get() {
      return (
        /*#__PURE__*/
        function (_DefaultFieldInstalle) {
          inheritsLoose(AliasedForwardsDescriptorInstaller, _DefaultFieldInstalle);

          function AliasedForwardsDescriptorInstaller() {
            return _DefaultFieldInstalle.apply(this, arguments) || this;
          }

          var _proto6 = AliasedForwardsDescriptorInstaller.prototype;

          _proto6.installForwardsDescriptor = function installForwardsDescriptor() {
            Object.defineProperty(this.model.prototype, this.field.as || this.fieldName, // use supplied name if possible
            this.field.createForwardsDescriptor(this.fieldName, this.model, this.toModel, this.throughModel));
          };

          return AliasedForwardsDescriptorInstaller;
        }(DefaultFieldInstaller)
      );
    }
  }]);

  return RelationalField;
}(Field);
/**
 * @ignore
 */


var ForeignKey =
/*#__PURE__*/
function (_RelationalField) {
  inheritsLoose(ForeignKey, _RelationalField);

  function ForeignKey() {
    var _this3;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    _this3 = _RelationalField.call.apply(_RelationalField, [this].concat(args)) || this;
    _this3.index = true;
    return _this3;
  }

  var _proto7 = ForeignKey.prototype;

  _proto7.createForwardsDescriptor = function createForwardsDescriptor(fieldName, model, toModel, throughModel) {
    return forwardsManyToOneDescriptor(fieldName, toModel.modelName);
  };

  _proto7.createBackwardsDescriptor = function createBackwardsDescriptor(fieldName, model, toModel, throughModel) {
    return backwardsManyToOneDescriptor(fieldName, model.modelName);
  };

  return ForeignKey;
}(RelationalField);
/**
 * @ignore
 */

var ManyToMany =
/*#__PURE__*/
function (_RelationalField2) {
  inheritsLoose(ManyToMany, _RelationalField2);

  function ManyToMany() {
    return _RelationalField2.apply(this, arguments) || this;
  }

  var _proto8 = ManyToMany.prototype;

  _proto8.getDefault = function getDefault() {
    return [];
  };

  _proto8.getThroughModelName = function getThroughModelName(fieldName, model) {
    return this.through || m2mName(model.modelName, fieldName);
  };

  _proto8.createForwardsDescriptor = function createForwardsDescriptor(fieldName, model, toModel, throughModel) {
    return manyToManyDescriptor(model.modelName, toModel.modelName, throughModel.modelName, this.getThroughFields(fieldName, model, toModel, throughModel), false);
  };

  _proto8.createBackwardsDescriptor = function createBackwardsDescriptor(fieldName, model, toModel, throughModel) {
    return manyToManyDescriptor(model.modelName, toModel.modelName, throughModel.modelName, this.getThroughFields(fieldName, model, toModel, throughModel), true);
  };

  _proto8.createBackwardsVirtualField = function createBackwardsVirtualField(fieldName, model, toModel, throughModel) {
    var ThisField = this.getClass();
    return new ThisField({
      to: model.modelName,
      relatedName: fieldName,
      through: throughModel.modelName,
      throughFields: this.getThroughFields(fieldName, model, toModel, throughModel)
    });
  };

  _proto8.createForwardsVirtualField = function createForwardsVirtualField(fieldName, model, toModel, throughModel) {
    var ThisField = this.getClass();
    return new ThisField({
      to: toModel.modelName,
      relatedName: fieldName,
      through: this.through,
      throughFields: this.getThroughFields(fieldName, model, toModel, throughModel)
    });
  };

  _proto8.getThroughFields = function getThroughFields(fieldName, model, toModel, throughModel) {
    if (this.throughFields) {
      var _this$throughFields = slicedToArray(this.throughFields, 2),
          fieldAName = _this$throughFields[0],
          fieldBName = _this$throughFields[1];

      var fieldA = throughModel.fields[fieldAName];
      return {
        to: fieldA.references(toModel) ? fieldAName : fieldBName,
        from: fieldA.references(toModel) ? fieldBName : fieldAName
      };
    }

    if (model.modelName === toModel.modelName) {
      /**
       * we have no way of determining the relationship's
       * direction here, so we need to assume that the user
       * did not use a custom through model
       * see ORM#registerManyToManyModelsFor
       */
      return {
        to: m2mToFieldName(toModel.modelName),
        from: m2mFromFieldName(model.modelName)
      };
    }
    /**
     * determine which field references which model
     * and infer the directions from that
     */


    var throughModelFieldReferencing = function throughModelFieldReferencing(otherModel) {
      return Object.keys(throughModel.fields).find(function (someFieldName) {
        return throughModel.fields[someFieldName].references(otherModel);
      });
    };

    return {
      to: throughModelFieldReferencing(toModel),
      from: throughModelFieldReferencing(model)
    };
  };

  createClass(ManyToMany, [{
    key: "installsForwardsVirtualField",
    get: function get() {
      return true;
    }
  }]);

  return ManyToMany;
}(RelationalField);
/**
 * @ignore
 */

var OneToOne =
/*#__PURE__*/
function (_RelationalField3) {
  inheritsLoose(OneToOne, _RelationalField3);

  function OneToOne() {
    return _RelationalField3.apply(this, arguments) || this;
  }

  var _proto9 = OneToOne.prototype;

  _proto9.getBackwardsFieldName = function getBackwardsFieldName(model) {
    return this.relatedName || model.modelName.toLowerCase();
  };

  _proto9.createForwardsDescriptor = function createForwardsDescriptor(fieldName, model, toModel, throughModel) {
    return forwardsOneToOneDescriptor(fieldName, toModel.modelName);
  };

  _proto9.createBackwardsDescriptor = function createBackwardsDescriptor(fieldName, model, toModel, throughModel) {
    return backwardsOneToOneDescriptor(fieldName, model.modelName);
  };

  return OneToOne;
}(RelationalField);
/**
 * Defines a value attribute on the model.
 * Though not required, it is recommended to define this for each non-foreign key you wish to use.
 * Getters and setters need to be defined on each Model
 * instantiation for undeclared data fields, which is slower.
 * You can use the optional `getDefault` parameter to fill in unpassed values
 * to {@link Model.create}, such as for generating ID's with UUID:
 *
 * ```javascript
 * import getUUID from 'your-uuid-package-of-choice';
 *
 * fields = {
 *   id: attr({ getDefault: () => getUUID() }),
 *   title: attr(),
 * }
 * ```
 *
 * @global
 *
 * @param  {Object} [opts]
 * @param {Function} [opts.getDefault] - if you give a function here, it's return
 *                                       value from calling with zero arguments will
 *                                       be used as the value when creating a new Model
 *                                       instance with {@link Model#create} if the field
 *                                       value is not passed.
 * @return {Attribute}
 */

function attr(opts) {
  return new Attribute(opts);
}
/**
 * Defines a foreign key on a model, which points
 * to a single entity on another model.
 *
 * You can pass arguments as either a single object,
 * or two arguments.
 *
 * If you pass two arguments, the first one is the name
 * of the Model the foreign key is pointing to, and
 * the second one is an optional related name, which will
 * be used to access the Model the foreign key
 * is being defined from, from the target Model.
 *
 * If the related name is not passed, it will be set as
 * `${toModelName}Set`.
 *
 * If you pass an object to `fk`, it has to be in the form
 *
 * ```javascript
 * fields = {
 *   author: fk({ to: 'Author', relatedName: 'books' })
 * }
 * ```
 *
 * Which is equal to
 *
 * ```javascript
 * fields = {
 *   author: fk('Author', 'books'),
 * }
 * ```
 *
 * @global
 *
 * @param  {string|Object} toModelNameOrObj - the `modelName` property of
 *                                            the Model that is the target of the
 *                                            foreign key, or an object with properties
 *                                            `to` and optionally `relatedName`.
 * @param {string} [relatedName] - if you didn't pass an object as the first argument,
 *                                 this is the property name that will be used to
 *                                 access a QuerySet the foreign key is defined from,
 *                                 from the target model.
 * @return {ForeignKey}
 */

function fk() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }

  return construct(ForeignKey, args);
}
/**
 * Defines a many-to-many relationship between
 * this (source) and another (target) model.
 *
 * The relationship is modeled with an extra model called the through model.
 * The through model has foreign keys to both the source and target models.
 *
 * You can define your own through model if you want to associate more information
 * to the relationship. A custom through model must have at least two foreign keys,
 * one pointing to the source Model, and one pointing to the target Model.
 *
 * If you have more than one foreign key pointing to a source or target Model in the
 * through Model, you must pass the option `throughFields`, which is an array of two
 * strings, where the strings are the field names that identify the foreign keys to
 * be used for the many-to-many relationship. Redux-ORM will figure out which field name
 * points to which model by checking the through Model definition.
 *
 * Unlike `fk`, this function accepts only an object argument.
 *
 * ```javascript
 * class Authorship extends Model {}
 * Authorship.modelName = 'Authorship';
 * Authorship.fields = {
 *   author: fk('Author', 'authorships'),
 *   book: fk('Book', 'authorships'),
 * };
 *
 * class Author extends Model {}
 * Author.modelName = 'Author';
 * Author.fields = {
 *   books: many({
 *     to: 'Book',
 *     relatedName: 'authors',
 *     through: 'Authorship',
 *
 *     // this is optional, since Redux-ORM can figure
 *     // out the through fields itself as there aren't
 *     // multiple foreign keys pointing to the same models.
 *     throughFields: ['author', 'book'],
 *   })
 * };
 *
 * class Book extends Model {}
 * Book.modelName = 'Book';
 * ```
 *
 * You should only define the many-to-many relationship on one side. In the
 * above case of Authors to Books through Authorships, the relationship is
 * defined only on the Author model.
 *
 * @global
 *
 * @param  {Object} options - options
 * @param  {string} options.to - the `modelName` attribute of the target Model.
 * @param  {string} [options.through] - the `modelName` attribute of the through Model which
 *                                    must declare at least one foreign key to both source and
 *                                    target Models. If not supplied, Redux-Orm will autogenerate
 *                                    one.
 * @param  {string[]} [options.throughFields] - this must be supplied only when a custom through
 *                                            Model has more than one foreign key pointing to
 *                                            either the source or target mode. In this case
 *                                            Redux-ORM can't figure out the correct fields for
 *                                            you, you must provide them. The supplied array should
 *                                            have two elements that are the field names for the
 *                                            through fields you want to declare the many-to-many
 *                                            relationship with. The order doesn't matter;
 *                                            Redux-ORM will figure out which field points to
 *                                            the source Model and which to the target Model.
 * @param  {string} [options.relatedName] - the attribute used to access a QuerySet
 *                                          of source Models from target Model.
 * @return {ManyToMany}
 */

function many() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  return construct(ManyToMany, args);
}
/**
 * Defines a one-to-one relationship. In database terms, this is a foreign key with the
 * added restriction that only one entity can point to single target entity.
 *
 * The arguments are the same as with `fk`. If `relatedName` is not supplied,
 * the source model name in lowercase will be used. Note that with the one-to-one
 * relationship, the `relatedName` should be in singular, not plural.
 *
 * @global
 *
 * @param  {string|Object} toModelNameOrObj - the `modelName` property of
 *                                            the Model that is the target of the
 *                                            foreign key, or an object with properties
 *                                            `to` and optionally `relatedName`.
 * @param {string} [relatedName] - if you didn't pass an object as the first argument,
 *                                 this is the property name that will be used to
 *                                 access a Model the foreign key is defined from,
 *                                 from the target Model.
 * @return {OneToOne}
 */

function oneToOne() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  return construct(OneToOne, args);
}

/**
 * Generates a query specification to get the instance's
 * corresponding table row using its primary key.
 *
 * @private
 * @returns {Object}
 */

function getByIdQuery(modelInstance) {
  var modelClass = modelInstance.getClass();
  var idAttribute = modelClass.idAttribute,
      modelName = modelClass.modelName;
  return {
    table: modelName,
    clauses: [{
      type: FILTER,
      payload: defineProperty({}, idAttribute, modelInstance.getId())
    }]
  };
}
/**
 * The heart of an ORM, the data model.
 *
 * The fields you specify to the Model will be used to generate
 * a schema to the database, related property accessors, and
 * possibly through models.
 *
 * In each {@link Session} you instantiate from an {@link ORM} instance,
 * you will receive a session-specific subclass of this Model. The methods
 * you define here will be available to you in sessions.
 *
 * An instance of {@link Model} represents a record in the database, though
 * it is possible to generate multiple instances from the same record in the database.
 *
 * To create data models in your schema, subclass {@link Model}. To define
 * information about the data model, override static class methods. Define instance
 * logic by defining prototype methods (without `static` keyword).
 */


var Model =
/*#__PURE__*/
function () {
  /**
   * Creates a Model instance from it's properties.
   * Don't use this to create a new record; Use the static method {@link Model#create}.
   * @param  {Object} props - the properties to instantiate with
   */
  function Model(props) {
    this._initFields(props);
  }

  var _proto = Model.prototype;

  _proto._initFields = function _initFields(props) {
    var _this = this;

    var propsObj = Object(props);
    this._fields = objectSpread({}, propsObj);
    Object.keys(propsObj).forEach(function (fieldName) {
      // In this case, we got a prop that wasn't defined as a field.
      // Assuming it's an arbitrary data field, making an instance-specific
      // descriptor for it.
      // Using the in operator as the property could be defined anywhere
      // on the prototype chain.
      if (!(fieldName in _this)) {
        Object.defineProperty(_this, fieldName, {
          get: function get() {
            return _this._fields[fieldName];
          },
          set: function set(value) {
            return _this.set(fieldName, value);
          },
          configurable: true,
          enumerable: true
        });
      }
    });
  };

  Model.toString = function toString() {
    return "ModelClass: ".concat(this.modelName);
  }
  /**
   * Returns the options object passed to the database for the table that represents
   * this Model class.
   *
   * Returns an empty object by default, which means the database
   * will use default options. You can either override this function to return the options
   * you want to use, or assign the options object as a static property of the same name to the
   * Model class.
   *
   * @return {Object} the options object passed to the database for the table
   *                  representing this Model class.
   */
  ;

  Model.options = function options() {
    return {};
  }
  /**
   * Manually mark individual instances as accessed.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @param {Array.<*>} ids - Array of primary key values
   * @return {undefined}
   */
  ;

  Model.markAccessed = function markAccessed(ids) {
    if (typeof this._session === 'undefined') {
      throw new Error(["Tried to mark rows of the ".concat(this.modelName, " model as accessed without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].markAccessed` instead.")].join(''));
    }

    this.session.markAccessed(this.modelName, ids);
  }
  /**
   * Manually mark this model's table as scanned.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @return {undefined}
   */
  ;

  Model.markFullTableScanned = function markFullTableScanned() {
    if (typeof this._session === 'undefined') {
      throw new Error(["Tried to mark the ".concat(this.modelName, " model as full table scanned without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].markFullTableScanned` instead.")].join(''));
    }

    this.session.markFullTableScanned(this.modelName);
  }
  /**
   * Manually mark indexes as accessed.
   * This allows invalidating selector memoization within mutable sessions.
   *
   * @param {Array.<Array.<*,*>>} indexes - Array of column-value pairs
   * @return {undefined}
   */
  ;

  Model.markAccessedIndexes = function markAccessedIndexes(indexes) {
    var _this2 = this;

    if (typeof this._session === 'undefined') {
      throw new Error(["Tried to mark indexes for the ".concat(this.modelName, " model as accessed without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].markAccessedIndexes` instead.")].join(''));
    }

    this.session.markAccessedIndexes(indexes.map(function (_ref) {
      var _ref2 = slicedToArray(_ref, 2),
          attribute = _ref2[0],
          value = _ref2[1];

      return [_this2.modelName, attribute, value];
    }));
  }
  /**
   * Returns the id attribute of this {@link Model}.
   *
   * @return {string} The id attribute of this {@link Model}.
   */
  ;

  /**
   * Connect the model class to a {@link Session}.
   *
   * @private
   * @param  {Session} session - The session to connect to.
   */
  Model.connect = function connect(session) {
    if (!(session instanceof Session)) {
      throw new Error('A model can only be connected to instances of Session.');
    }

    this._session = session;
  }
  /**
   * Get the current {@link Session} instance.
   *
   * @private
   * @return {Session} The current {@link Session} instance.
   */
  ;

  /**
   * Returns an instance of the model's `querySetClass` field.
   * By default, this will be an empty {@link QuerySet}.
   *
   * @return {Object} An instance of the model's `querySetClass`.
   */
  Model.getQuerySet = function getQuerySet() {
    var QuerySetClass = this.querySetClass;
    return new QuerySetClass(this);
  }
  /**
   * @return {undefined}
   */
  ;

  Model.invalidateClassCache = function invalidateClassCache() {
    this.isSetUp = undefined;
    this.virtualFields = {};
  }
  /**
   * @see {@link Model.getQuerySet}
   */
  ;

  /**
   * @private
   */
  Model._getTableOpts = function _getTableOpts() {
    if (typeof this.backend === 'function') {
      warnDeprecated('`Model.backend` has been deprecated. Please rename to `.options`.');
      return this.backend();
    }

    if (this.backend) {
      warnDeprecated('`Model.backend` has been deprecated. Please rename to `.options`.');
      return this.backend;
    }

    if (typeof this.options === 'function') {
      return this.options();
    }

    return this.options;
  }
  /**
   * Creates a new record in the database, instantiates a {@link Model} and returns it.
   *
   * If you pass values for many-to-many fields, instances are created on the through
   * model as well.
   *
   * @param  {props} userProps - the new {@link Model}'s properties.
   * @return {Model} a new {@link Model} instance.
   */
  ;

  Model.create = function create(userProps) {
    var _this3 = this;

    if (typeof this._session === 'undefined') {
      throw new Error(["Tried to create a ".concat(this.modelName, " model instance without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].create` instead.")].join(''));
    }

    var props = objectSpread({}, userProps);

    var m2mRelations = {};
    var declaredFieldNames = Object.keys(this.fields);
    var declaredVirtualFieldNames = Object.keys(this.virtualFields);
    declaredFieldNames.forEach(function (key) {
      var field = _this3.fields[key];
      var valuePassed = userProps.hasOwnProperty(key);

      if (!(field instanceof ManyToMany)) {
        if (valuePassed) {
          var value = userProps[key];
          props[key] = normalizeEntity(value);
        } else if (field.getDefault) {
          props[key] = field.getDefault();
        }
      } else if (valuePassed) {
        // If a value is supplied for a ManyToMany field,
        // discard them from props and save for later processing.
        m2mRelations[key] = userProps[key];
        delete props[key];
      }
    }); // add backward many-many if required

    declaredVirtualFieldNames.forEach(function (key) {
      if (!m2mRelations.hasOwnProperty(key)) {
        var field = _this3.virtualFields[key];

        if (userProps.hasOwnProperty(key) && field instanceof ManyToMany) {
          // If a value is supplied for a ManyToMany field,
          // discard them from props and save for later processing.
          m2mRelations[key] = userProps[key];
          delete props[key];
        }
      }
    });
    var newEntry = this.session.applyUpdate({
      action: CREATE,
      table: this.modelName,
      payload: props
    });
    var ThisModel = this;
    var instance = new ThisModel(newEntry);

    instance._refreshMany2Many(m2mRelations); // eslint-disable-line no-underscore-dangle


    return instance;
  }
  /**
   * Creates a new or update existing record in the database, instantiates a {@link Model} and returns it.
   *
   * If you pass values for many-to-many fields, instances are created on the through
   * model as well.
   *
   * @param  {props} userProps - the required {@link Model}'s properties.
   * @return {Model} a {@link Model} instance.
   */
  ;

  Model.upsert = function upsert(userProps) {
    if (typeof this.session === 'undefined') {
      throw new Error(["Tried to upsert a ".concat(this.modelName, " model instance without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].upsert` instead.")].join(''));
    }

    var idAttribute = this.idAttribute;

    if (userProps.hasOwnProperty(idAttribute)) {
      var id = userProps[idAttribute];

      if (this.idExists(id)) {
        var model = this.withId(id);
        model.update(userProps);
        return model;
      }
    }

    return this.create(userProps);
  }
  /**
   * Returns a {@link Model} instance for the object with id `id`.
   * Returns `null` if the model has no instance with id `id`.
   *
   * You can use {@link Model#idExists} to check for existence instead.
   *
   * @param  {*} id - the `id` of the object to get
   * @throws If object with id `id` doesn't exist
   * @return {Model|null} {@link Model} instance with id `id`
   */
  ;

  Model.withId = function withId(id) {
    return this.get(defineProperty({}, this.idAttribute, id));
  }
  /**
   * Returns a boolean indicating if an entity
   * with the id `id` exists in the state.
   *
   * @param  {*}  id - a value corresponding to the id attribute of the {@link Model} class.
   * @return {Boolean} a boolean indicating if entity with `id` exists in the state
   *
   * @since 0.11.0
   */
  ;

  Model.idExists = function idExists(id) {
    return this.exists(defineProperty({}, this.idAttribute, id));
  }
  /**
   * Returns a boolean indicating if an entity
   * with the given props exists in the state.
   *
   * @param  {*}  props - a key-value that {@link Model} instances should have to be considered as existing.
   * @return {Boolean} a boolean indicating if entity with `props` exists in the state
   */
  ;

  Model.exists = function exists(lookupObj) {
    if (typeof this.session === 'undefined') {
      throw new Error(["Tried to check if a ".concat(this.modelName, " model instance exists without a session. "), 'Create a session using `session = orm.session()` and call ', "`session[\"".concat(this.modelName, "\"].exists` instead.")].join(''));
    }

    return Boolean(this._findDatabaseRows(lookupObj).length);
  }
  /**
   * Gets the {@link Model} instance that matches properties in `lookupObj`.
   * Throws an error if {@link Model} if multiple records match
   * the properties.
   *
   * @param  {Object} lookupObj - the properties used to match a single entity.
   * @throws {Error} If more than one entity matches the properties in `lookupObj`.
   * @return {Model} a {@link Model} instance that matches the properties in `lookupObj`.
   */
  ;

  Model.get = function get(lookupObj) {
    var ThisModel = this;

    var rows = this._findDatabaseRows(lookupObj);

    if (rows.length === 0) {
      return null;
    }

    if (rows.length > 1) {
      throw new Error("Expected to find a single row in `".concat(this.modelName, ".get`. Found ").concat(rows.length, "."));
    }

    return new ThisModel(rows[0]);
  }
  /**
   * Gets the {@link Model} class or subclass constructor (the class that
   * instantiated this instance).
   *
   * @return {Model} The {@link Model} class or subclass constructor used to instantiate
   *                 this instance.
   */
  ;

  _proto.getClass = function getClass() {
    return this.constructor;
  }
  /**
   * Gets the id value of the current instance by looking up the id attribute.
   * @return {*} The id value of the current instance.
   */
  ;

  _proto.getId = function getId() {
    return this._fields[this.getClass().idAttribute];
  }
  /**
   * Returns a reference to the plain JS object in the store.
   * Make sure to not mutate this.
   *
   * @return {Object} a reference to the plain JS object in the store
   */
  ;

  /**
   * Finds all rows in this model's table that match the given `lookupObj`.
   * If no `lookupObj` is passed, all rows in the model's table will be returned.
   *
   * @param  {*}  props - a key-value that {@link Model} instances should have to be considered as existing.
   * @return {Boolean} a boolean indicating if entity with `props` exists in the state
   * @private
   */
  Model._findDatabaseRows = function _findDatabaseRows(lookupObj) {
    var querySpec = {
      table: this.modelName
    };

    if (lookupObj) {
      querySpec.clauses = [{
        type: FILTER,
        payload: lookupObj
      }];
    }

    return this.session.query(querySpec).rows;
  }
  /**
   * Returns a string representation of the {@link Model} instance.
   *
   * @return {string} A string representation of this {@link Model} instance.
   */
  ;

  _proto.toString = function toString() {
    var _this4 = this;

    var ThisModel = this.getClass();
    var className = ThisModel.modelName;
    var fieldNames = Object.keys(ThisModel.fields);
    var fields = fieldNames.map(function (fieldName) {
      var field = ThisModel.fields[fieldName];

      if (field instanceof ManyToMany) {
        var ids = _this4[fieldName].toModelArray().map(function (model) {
          return model.getId();
        });

        return "".concat(fieldName, ": [").concat(ids.join(', '), "]");
      }

      var val = _this4._fields[fieldName];
      return "".concat(fieldName, ": ").concat(val);
    }).join(', ');
    return "".concat(className, ": {").concat(fields, "}");
  }
  /**
   * Returns a boolean indicating if `otherModel` equals this {@link Model} instance.
   * Equality is determined by shallow comparing their attributes.
   *
   * This equality is used when you call {@link Model#update}.
   * You can prevent model updates by returning `true` here.
   * However, a model will always be updated if its relationships are changed.
   *
   * @param  {Model} otherModel - a {@link Model} instance to compare
   * @return {Boolean} a boolean indicating if the {@link Model} instance's are equal.
   */
  ;

  _proto.equals = function equals(otherModel) {
    // eslint-disable-next-line no-underscore-dangle
    return objectShallowEquals(this._fields, otherModel._fields);
  }
  /**
   * Updates a property name to given value for this {@link Model} instance.
   * The values are immediately committed to the database.
   *
   * @param {string} propertyName - name of the property to set
   * @param {*} value - value assigned to the property
   * @return {undefined}
   */
  ;

  _proto.set = function set(propertyName, value) {
    this.update(defineProperty({}, propertyName, value));
  }
  /**
   * Assigns multiple fields and corresponding values to this {@link Model} instance.
   * The updates are immediately committed to the database.
   *
   * @param  {Object} userMergeObj - an object that will be merged with this instance.
   * @return {undefined}
   */
  ;

  _proto.update = function update(userMergeObj) {
    var _this5 = this;

    var ThisModel = this.getClass();

    if (typeof ThisModel.session === 'undefined') {
      throw new Error(["Tried to update a ".concat(ThisModel.modelName, " model instance without a session. "), 'You cannot call `.update` on an instance that you did not receive from the database.'].join(''));
    }

    var mergeObj = objectSpread({}, userMergeObj);

    var fields = ThisModel.fields,
        virtualFields = ThisModel.virtualFields;
    var m2mRelations = {}; // If an array of entities or id's is supplied for a
    // many-to-many related field, clear the old relations
    // and add the new ones.

    for (var mergeKey in mergeObj) {
      // eslint-disable-line no-restricted-syntax, guard-for-in
      var isRealField = fields.hasOwnProperty(mergeKey);

      if (isRealField) {
        var field = fields[mergeKey];

        if (field instanceof ForeignKey || field instanceof OneToOne) {
          // update one-one/fk relations
          mergeObj[mergeKey] = normalizeEntity(mergeObj[mergeKey]);
        } else if (field instanceof ManyToMany) {
          // field is forward relation
          m2mRelations[mergeKey] = mergeObj[mergeKey];
          delete mergeObj[mergeKey];
        }
      } else if (virtualFields.hasOwnProperty(mergeKey)) {
        var _field = virtualFields[mergeKey];

        if (_field instanceof ManyToMany) {
          // field is backward relation
          m2mRelations[mergeKey] = mergeObj[mergeKey];
          delete mergeObj[mergeKey];
        }
      }
    }

    var mergedFields = objectSpread({}, this._fields, mergeObj);

    var updatedModel = new ThisModel(this._fields);

    updatedModel._initFields(mergedFields); // eslint-disable-line no-underscore-dangle
    // determine if model would have different related models after update


    updatedModel._refreshMany2Many(m2mRelations); // eslint-disable-line no-underscore-dangle


    var relationsEqual = Object.keys(m2mRelations).every(function (name) {
      return !arrayDiffActions(_this5[name], updatedModel[name]);
    });
    var fieldsEqual = this.equals(updatedModel); // only update fields if they have changed (referentially)

    if (!fieldsEqual) {
      this._initFields(mergedFields);
    } // only update many-to-many relationships if any reference has changed


    if (!relationsEqual) {
      this._refreshMany2Many(m2mRelations);
    } // only apply the update if a field or relationship has changed


    if (!fieldsEqual || !relationsEqual) {
      ThisModel.session.applyUpdate({
        action: UPDATE,
        query: getByIdQuery(this),
        payload: mergeObj
      });
    }
  }
  /**
   * Updates {@link Model} instance attributes to reflect the
   * database state in the current session.
   * @return {undefined}
   */
  ;

  _proto.refreshFromState = function refreshFromState() {
    this._initFields(this.ref);
  }
  /**
   * Deletes the record for this {@link Model} instance.
   * You'll still be able to access fields and values on the instance.
   *
   * @return {undefined}
   */
  ;

  _proto.delete = function _delete() {
    var ThisModel = this.getClass();

    if (typeof ThisModel.session === 'undefined') {
      throw new Error(["Tried to delete a ".concat(ThisModel.modelName, " model instance without a session. "), 'You cannot call `.delete` on an instance that you did not receive from the database.'].join(''));
    }

    this._onDelete();

    ThisModel.session.applyUpdate({
      action: DELETE,
      query: getByIdQuery(this)
    });
  }
  /**
   * Update many-many relations for model.
   * @param relations
   * @return undefined
   * @private
   */
  ;

  _proto._refreshMany2Many = function _refreshMany2Many(relations) {
    var _this6 = this;

    var ThisModel = this.getClass();
    var fields = ThisModel.fields,
        virtualFields = ThisModel.virtualFields,
        modelName = ThisModel.modelName;
    Object.keys(relations).forEach(function (name) {
      var reverse = !fields.hasOwnProperty(name);
      var field = virtualFields[name];
      var values = relations[name];

      if (!Array.isArray(values)) {
        throw new TypeError("Failed to resolve many-to-many relationship: ".concat(modelName, "[").concat(name, "] must be an array (passed: ").concat(values, ")"));
      }

      var normalizedNewIds = values.map(normalizeEntity);

      var uniqueIds = toConsumableArray(new Set(normalizedNewIds));

      if (normalizedNewIds.length !== uniqueIds.length) {
        throw new Error("Found duplicate id(s) when passing \"".concat(normalizedNewIds, "\" to ").concat(ThisModel.modelName, ".").concat(name, " value"));
      }

      var throughModelName = field.through || m2mName(ThisModel.modelName, name);
      var ThroughModel = ThisModel.session[throughModelName];
      var fromField;
      var toField;

      if (!reverse) {
        var _field$throughFields = field.throughFields;
        fromField = _field$throughFields.from;
        toField = _field$throughFields.to;
      } else {
        var _field$throughFields2 = field.throughFields;
        toField = _field$throughFields2.from;
        fromField = _field$throughFields2.to;
      }

      var currentIds = ThroughModel.filter(function (through) {
        return through[fromField] === _this6[ThisModel.idAttribute];
      }).toRefArray().map(function (ref) {
        return ref[toField];
      });
      var diffActions = arrayDiffActions(currentIds, normalizedNewIds);

      if (diffActions) {
        var idsToDelete = diffActions.delete,
            idsToAdd = diffActions.add;

        if (idsToDelete.length > 0) {
          var _this6$name;

          (_this6$name = _this6[name]).remove.apply(_this6$name, toConsumableArray(idsToDelete));
        }

        if (idsToAdd.length > 0) {
          var _this6$name2;

          (_this6$name2 = _this6[name]).add.apply(_this6$name2, toConsumableArray(idsToAdd));
        }
      }
    });
  }
  /**
   * @return {undefined}
   * @private
   */
  ;

  _proto._onDelete = function _onDelete() {
    var _this$getClass = this.getClass(),
        virtualFields = _this$getClass.virtualFields;

    for (var key in virtualFields) {
      // eslint-disable-line
      var field = virtualFields[key];

      if (field instanceof ManyToMany) {
        // Delete any many-to-many rows the entity is included in.
        this[key].clear();
      } else if (field instanceof ForeignKey) {
        var relatedQs = this[key];

        if (relatedQs.exists()) {
          relatedQs.update(defineProperty({}, field.relatedName, null));
        }
      } else if (field instanceof OneToOne) {
        // Set null to any foreign keys or one to ones pointed to
        // this instance.
        if (this[key] !== null) {
          this[key][field.relatedName] = null;
        }
      }
    }
  } // DEPRECATED AND REMOVED METHODS

  /**
   * Returns a boolean indicating if an entity
   * with the id `id` exists in the state.
   *
   * @param  {*}  id - a value corresponding to the id attribute of the {@link Model} class.
   * @return {Boolean} a boolean indicating if entity with `id` exists in the state
   * @deprecated Please use {@link Model.idExists} instead.
   */
  ;

  Model.hasId = function hasId(id) {
    console.warn('`Model.hasId` has been deprecated. Please use `Model.idExists` instead.');
    return this.idExists(id);
  }
  /**
   * @deprecated See the 0.9 migration guide on the GitHub repo.
   * @throws {Error} Due to deprecation.
   */
  ;

  _proto.getNextState = function getNextState() {
    throw new Error('`Model.prototype.getNextState` has been removed. See the 0.9 ' + 'migration guide on the GitHub repo.');
  };

  createClass(Model, [{
    key: "ref",
    get: function get() {
      var ThisModel = this.getClass(); // eslint-disable-next-line no-underscore-dangle

      return ThisModel._findDatabaseRows(defineProperty({}, ThisModel.idAttribute, this.getId()))[0];
    }
  }], [{
    key: "idAttribute",
    get: function get() {
      if (typeof this._session === 'undefined') {
        throw new Error(["Tried to get the ".concat(this.modelName, " model's id attribute without a session. "), 'Create a session using `session = orm.session()` and access ', "`session[\"".concat(this.modelName, "\"].idAttribute` instead.")].join(''));
      }

      return this.session.db.describe(this.modelName).idAttribute;
    }
  }, {
    key: "session",
    get: function get() {
      return this._session;
    }
  }, {
    key: "query",
    get: function get() {
      return this.getQuerySet();
    }
  }]);

  return Model;
}();

Model.fields = {
  id: attr()
};
Model.virtualFields = {};
Model.querySetClass = QuerySet;

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

var _arrayFilter = arrayFilter;

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

var _createBaseFor = createBaseFor;

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

var _baseFor = baseFor;

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

var _baseTimes = baseTimes;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

var _freeGlobal = freeGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal || freeSelf || Function('return this')();

var _root = root;

/** Built-in value references. */
var Symbol$1 = _root.Symbol;

var _Symbol = Symbol$1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

var _getRawTag = getRawTag;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString$1.call(value);
}

var _objectToString = objectToString;

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag$1 && symToStringTag$1 in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

var _baseGetTag = baseGetTag;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

var isObjectLike_1 = isObjectLike;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag;
}

var _baseIsArguments = baseIsArguments;

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$2.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$1.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

var isArguments_1 = isArguments;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

var isArray_1 = isArray;

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

var stubFalse_1 = stubFalse;

var isBuffer_1 = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse_1;

module.exports = isBuffer;
});

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

var _isIndex = isIndex;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

var isLength_1 = isLength;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike_1(value) &&
    isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

var _baseIsTypedArray = baseIsTypedArray;

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

var _baseUnary = baseUnary;

var _nodeUtil = createCommonjsModule(function (module, exports) {
/** Detect free variable `exports`. */
var freeExports =  exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;
});

/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

var isTypedArray_1 = isTypedArray;

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value),
      isArg = !isArr && isArguments_1(value),
      isBuff = !isArr && !isArg && isBuffer_1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray_1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$2.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

var _arrayLikeKeys = arrayLikeKeys;

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$4;

  return value === proto;
}

var _isPrototype = isPrototype;

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

var _overArg = overArg;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

var _nativeKeys = nativeKeys;

/** Used for built-in method references. */
var objectProto$5 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$5.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$3.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

var _baseKeys = baseKeys;

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

var isObject_1 = isObject;

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

var isFunction_1 = isFunction;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength_1(value.length) && !isFunction_1(value);
}

var isArrayLike_1 = isArrayLike$1;

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike_1(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

var keys_1 = keys;

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && _baseFor(object, iteratee, keys_1);
}

var _baseForOwn = baseForOwn;

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

var _createBaseEach = createBaseEach;

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = _createBaseEach(_baseForOwn);

var _baseEach = baseEach;

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  _baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

var _baseFilter = baseFilter;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

var _listCacheClear = listCacheClear;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

var eq_1 = eq;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq_1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

var _assocIndexOf = assocIndexOf;

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

var _listCacheDelete = listCacheDelete;

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

var _listCacheGet = listCacheGet;

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

var _listCacheHas = listCacheHas;

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

var _listCacheSet = listCacheSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

var _ListCache = ListCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

var _stackClear = stackClear;

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

var _stackDelete = stackDelete;

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

var _stackGet = stackGet;

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

var _stackHas = stackHas;

/** Used to detect overreaching core-js shims. */
var coreJsData = _root['__core-js_shared__'];

var _coreJsData = coreJsData;

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

var _isMasked = isMasked;

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

var _toSource = toSource;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$6 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$6.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$4).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

var _baseIsNative = baseIsNative;

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

var _getValue = getValue;

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = _getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

var _getNative = getNative;

/* Built-in method references that are verified to be native. */
var Map = _getNative(_root, 'Map');

var _Map = Map;

/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

var _nativeCreate = nativeCreate;

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

var _hashClear = hashClear;

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

var _hashDelete = hashDelete;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$5.call(data, key) ? data[key] : undefined;
}

var _hashGet = hashGet;

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : hasOwnProperty$6.call(data, key);
}

var _hashHas = hashHas;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

var _hashSet = hashSet;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

var _Hash = Hash;

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

var _mapCacheClear = mapCacheClear;

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

var _isKeyable = isKeyable;

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

var _getMapData = getMapData;

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

var _mapCacheDelete = mapCacheDelete;

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

var _mapCacheGet = mapCacheGet;

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

var _mapCacheHas = mapCacheHas;

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

var _mapCacheSet = mapCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

var _MapCache = MapCache;

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

var _stackSet = stackSet;

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

var _Stack = Stack;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED$2);
  return this;
}

var _setCacheAdd = setCacheAdd;

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

var _setCacheHas = setCacheHas;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

var _SetCache = SetCache;

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

var _arraySome = arraySome;

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

var _cacheHas = cacheHas;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

var _equalArrays = equalArrays;

/** Built-in value references. */
var Uint8Array = _root.Uint8Array;

var _Uint8Array = Uint8Array;

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

var _mapToArray = mapToArray;

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

var _setToArray = setToArray;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

/** `Object#toString` result references. */
var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$1 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$1:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag$1:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag$1:
    case dateTag$1:
    case numberTag$1:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq_1(+object, +other);

    case errorTag$1:
      return object.name == other.name && object.message == other.message;

    case regexpTag$1:
    case stringTag$1:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag$1:
      var convert = _mapToArray;

    case setTag$1:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$1;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$1;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

var _equalByTag = equalByTag;

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

var _arrayPush = arrayPush;

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray_1(object) ? result : _arrayPush(result, symbolsFunc(object));
}

var _baseGetAllKeys = baseGetAllKeys;

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var stubArray_1 = stubArray;

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray_1 : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable$1.call(object, symbol);
  });
};

var _getSymbols = getSymbols;

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, keys_1, _getSymbols);
}

var _getAllKeys = getAllKeys;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$2 = 1;

/** Used for built-in method references. */
var objectProto$a = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$a.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$2,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$7.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

var _equalObjects = equalObjects;

/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root, 'DataView');

var _DataView = DataView;

/* Built-in method references that are verified to be native. */
var Promise = _getNative(_root, 'Promise');

var _Promise = Promise;

/* Built-in method references that are verified to be native. */
var Set$1 = _getNative(_root, 'Set');

var _Set = Set$1;

/* Built-in method references that are verified to be native. */
var WeakMap = _getNative(_root, 'WeakMap');

var _WeakMap = WeakMap;

/** `Object#toString` result references. */
var mapTag$2 = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$2 = '[object Set]',
    weakMapTag$1 = '[object WeakMap]';

var dataViewTag$2 = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag$2) ||
    (_Map && getTag(new _Map) != mapTag$2) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != setTag$2) ||
    (_WeakMap && getTag(new _WeakMap) != weakMapTag$1)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag$2;
        case mapCtorString: return mapTag$2;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$2;
        case weakMapCtorString: return weakMapTag$1;
      }
    }
    return result;
  };
}

var _getTag = getTag;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$3 = 1;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object),
      othIsArr = isArray_1(other),
      objTag = objIsArr ? arrayTag$1 : _getTag(object),
      othTag = othIsArr ? arrayTag$1 : _getTag(other);

  objTag = objTag == argsTag$2 ? objectTag$2 : objTag;
  othTag = othTag == argsTag$2 ? objectTag$2 : othTag;

  var objIsObj = objTag == objectTag$2,
      othIsObj = othTag == objectTag$2,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer_1(object)) {
    if (!isBuffer_1(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || isTypedArray_1(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$3)) {
    var objIsWrapped = objIsObj && hasOwnProperty$8.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty$8.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

var _baseIsEqualDeep = baseIsEqualDeep;

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike_1(value) && !isObjectLike_1(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

var _baseIsEqual = baseIsEqual;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new _Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$4 | COMPARE_UNORDERED_FLAG$2, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

var _baseIsMatch = baseIsMatch;

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject_1(value);
}

var _isStrictComparable = isStrictComparable;

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys_1(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}

var _getMatchData = getMatchData;

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

var _matchesStrictComparable = matchesStrictComparable;

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || _baseIsMatch(object, source, matchData);
  };
}

var _baseMatches = baseMatches;

/** `Object#toString` result references. */
var symbolTag$1 = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike_1(value) && _baseGetTag(value) == symbolTag$1);
}

var isSymbol_1 = isSymbol;

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

var _isKey = isKey;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

var memoize_1 = memoize;

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

var _memoizeCapped = memoizeCapped;

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

var _stringToPath = stringToPath;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

var _arrayMap = arrayMap;

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray_1(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (isSymbol_1(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

var _baseToString = baseToString;

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : _baseToString(value);
}

var toString_1 = toString;

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(toString_1(value));
}

var _castPath = castPath;

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol_1(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

var _toKey = toKey;

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

var _baseGet = baseGet;

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

var get_1 = get;

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

var _baseHasIn = baseHasIn;

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = _toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength_1(length) && _isIndex(key, length) &&
    (isArray_1(object) || isArguments_1(object));
}

var _hasPath = hasPath;

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && _hasPath(object, path, _baseHasIn);
}

var hasIn_1 = hasIn;

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get_1(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn_1(object, path)
      : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$5 | COMPARE_UNORDERED_FLAG$3);
  };
}

var _baseMatchesProperty = baseMatchesProperty;

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

var identity_1 = identity;

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

var _baseProperty = baseProperty;

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return _baseGet(object, path);
  };
}

var _basePropertyDeep = basePropertyDeep;

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}

var property_1 = property;

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity_1;
  }
  if (typeof value == 'object') {
    return isArray_1(value)
      ? _baseMatchesProperty(value[0], value[1])
      : _baseMatches(value);
  }
  return property_1(value);
}

var _baseIteratee = baseIteratee;

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

var negate_1 = negate;

/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
  return func(collection, negate_1(_baseIteratee(predicate)));
}

var reject_1 = reject;

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 */
function filter(collection, predicate) {
  var func = isArray_1(collection) ? _arrayFilter : _baseFilter;
  return func(collection, _baseIteratee(predicate));
}

var filter_1 = filter;

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike_1(collection) ? Array(collection.length) : [];

  _baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

var _baseMap = baseMap;

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

var _baseSortBy = baseSortBy;

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol_1(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol_1(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

var _compareAscending = compareAscending;

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = _compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

var _compareMultiple = compareMultiple;

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  var index = -1;
  iteratees = _arrayMap(iteratees.length ? iteratees : [identity_1], _baseUnary(_baseIteratee));

  var result = _baseMap(collection, function(value, key, collection) {
    var criteria = _arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return _baseSortBy(result, function(object, other) {
    return _compareMultiple(object, other, orders);
  });
}

var _baseOrderBy = baseOrderBy;

/**
 * This method is like `_.sortBy` except that it allows specifying the sort
 * orders of the iteratees to sort by. If `orders` is unspecified, all values
 * are sorted in ascending order. Otherwise, specify an order of "desc" for
 * descending or "asc" for ascending sort order of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @param {string[]} [orders] The sort orders of `iteratees`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 34 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 36 }
 * ];
 *
 * // Sort by `user` in ascending order and by `age` in descending order.
 * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 */
function orderBy(collection, iteratees, orders, guard) {
  if (collection == null) {
    return [];
  }
  if (!isArray_1(iteratees)) {
    iteratees = iteratees == null ? [] : [iteratees];
  }
  orders = guard ? undefined : orders;
  if (!isArray_1(orders)) {
    orders = orders == null ? [] : [orders];
  }
  return _baseOrderBy(collection, iteratees, orders);
}

var orderBy_1 = orderBy;

/** Built-in value references. */
var spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

var _isFlattenable = isFlattenable;

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = _isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

var _baseFlatten = baseFlatten;

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

var _apply = apply;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

var _overRest = overRest;

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

var constant_1 = constant;

var defineProperty$1 = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

var _defineProperty$1 = defineProperty$1;

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string) {
  return _defineProperty$1(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant_1(string),
    'writable': true
  });
};

var _baseSetToString = baseSetToString;

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

var _shortOut = shortOut;

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

var _setToString = setToString;

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, identity_1), func + '');
}

var _baseRest = baseRest;

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject_1(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike_1(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq_1(object[index], value);
  }
  return false;
}

var _isIterateeCall = isIterateeCall;

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 40 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
 */
var sortBy = _baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && _isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && _isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return _baseOrderBy(collection, _baseFlatten(iteratees, 1), []);
});

var sortBy_1 = sortBy;

var DEFAULT_TABLE_OPTIONS = {
  idAttribute: 'id',
  arrName: 'items',
  mapName: 'itemsById',
  fields: {}
}; // Input is the current max id and the new id passed to the create action.
// Both may be undefined. The current max id in the case that this is the first Model
// being created, and the new id if the id was not explicitly passed to the
// database.
//
// Return value is the new max id and the id to use to create the new row.
// If the id's are strings, the id must be passed explicitly every time.
// In this case, the current max id will remain `NaN` due to `Math.max`, but that's fine.

function idSequencer(_currMax, userPassedId) {
  var currMax = _currMax;
  var newMax;
  var newId;

  if (currMax === undefined) {
    currMax = -1;
  }

  if (userPassedId === undefined) {
    newMax = currMax + 1;
    newId = newMax;
  } else {
    newMax = Math.max(currMax + 1, userPassedId);
    newId = userPassedId;
  }

  return [newMax, // new max id
  newId];
}
/**
 * Handles the underlying data structure for a {@link Model} class.
 */


var Table =
/*#__PURE__*/
function () {
  /**
   * Creates a new {@link Table} instance.
   * @param  {Object} userOpts - options to use.
   * @param  {string} [userOpts.idAttribute=id] - the id attribute of the entity.
   * @param  {string} [userOpts.arrName=items] - the state attribute where an array of
   *                                             entity id's are stored
   * @param  {string} [userOpts.mapName=itemsById] - the state attribute where the entity objects
   *                                                 are stored in a id to entity object
   *                                                 map.
   * @param  {string} [userOpts.fields={}] - mapping of field key to {@link Field} object
   */
  function Table(userOpts) {
    Object.assign(this, DEFAULT_TABLE_OPTIONS, userOpts);
  }
  /**
   * Returns a reference to the object at index `id`
   * in state `branch`.
   *
   * @param  {Object} branch - the state
   * @param  {Number} id - the id of the object to get
   * @return {Object|undefined} A reference to the raw object in the state or
   *                            `undefined` if not found.
   */


  var _proto = Table.prototype;

  _proto.accessId = function accessId(branch, id) {
    return branch[this.mapName][id];
  };

  _proto.accessIds = function accessIds(branch, ids) {
    var map = branch[this.mapName];
    return ids.map(function (id) {
      return map[id];
    });
  };

  _proto.idExists = function idExists(branch, id) {
    return branch[this.mapName].hasOwnProperty(id);
  };

  _proto.accessIdList = function accessIdList(branch) {
    return branch[this.arrName];
  };

  _proto.accessList = function accessList(branch) {
    return this.accessIds(branch, this.accessIdList(branch));
  };

  _proto.getMaxId = function getMaxId(branch) {
    return this.getMeta(branch, 'maxId');
  };

  _proto.setMaxId = function setMaxId(tx, branch, newMaxId) {
    return this.setMeta(tx, branch, 'maxId', newMaxId);
  };

  _proto.nextId = function nextId(id) {
    return id + 1;
  }
  /**
   * Returns the default state for the data structure.
   * @return {Object} The default state for this {@link ORM} instance's data structure
   */
  ;

  _proto.getEmptyState = function getEmptyState() {
    var _pkIndex,
        _this = this;

    var pkIndex = (_pkIndex = {}, defineProperty(_pkIndex, this.arrName, []), defineProperty(_pkIndex, this.mapName, {}), _pkIndex);
    var attrIndexes = Object.keys(this.fields).filter(function (attr) {
      return attr !== _this.idAttribute;
    }).filter(function (attr) {
      return _this.fields[attr].index;
    }).reduce(function (indexes, attr) {
      return objectSpread({}, indexes, defineProperty({}, attr, {}));
    }, {});
    return objectSpread({}, pkIndex, {
      indexes: attrIndexes,
      meta: {}
    });
  };

  _proto.setMeta = function setMeta(tx, branch, key, value) {
    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;

    if (withMutations) {
      var res = ops.mutable.setIn(['meta', key], value, branch);
      return res;
    }

    return ops.batch.setIn(batchToken, ['meta', key], value, branch);
  };

  _proto.getMeta = function getMeta(branch, key) {
    return branch.meta[key];
  };

  _proto.query = function query(branch, clauses) {
    var _this2 = this;

    if (clauses.length === 0) {
      return this.accessList(branch);
    }

    var idAttribute = this.idAttribute;
    var optimallyOrderedClauses = sortBy_1(clauses, function (clause) {
      if (clauseFiltersByAttribute(clause, idAttribute)) {
        return 1;
      }

      if (clauseReducesResultSetSize(clause)) {
        return 2;
      }

      return 3;
    });

    var reducer = function reducer(rows, clause) {
      var type = clause.type,
          payload = clause.payload;

      if (!rows) {
        /**
         * First time this reducer is called during query.
         * This is where we apply query optimizations.
         */
        if (clauseFiltersByAttribute(clause, idAttribute)) {
          /**
           * Payload specified a primary key. Use PK index
           * to look up the single row identified by the PK.
           */
          var id = payload[idAttribute];
          var remainingPayload = Object.keys(payload).reduce(function (withoutPkAttr, filterAttr) {
            if (filterAttr !== idAttribute) {
              withoutPkAttr[filterAttr] = payload[filterAttr];
            }

            return withoutPkAttr;
          }, {});
          var ids = _this2.idExists(branch, id) ? [id] : [];

          if (Object.keys(remainingPayload).length) {
            /**
             * Payload has additional, non-PK columns.
             * Filter accessed row by remaining payload (if one was found).
             */
            return reducer(_this2.accessIds(branch, ids), objectSpread({}, clause, {
              payload: remainingPayload
            }));
          }
          /**
           * No need to filter these rows any further.
           * The primary key value satisfies this clause's conditions.
           */


          return _this2.accessIds(branch, ids);
        }

        if (type === FILTER && _typeof_1(payload) === 'object') {
          var indexes = Object.entries(branch.indexes);
          var accessedIndexes = [];
          var indexAttrs = [];
          indexes.forEach(function (_ref) {
            var _ref2 = slicedToArray(_ref, 2),
                attr = _ref2[0],
                index = _ref2[1];

            if (clauseFiltersByAttribute(clause, attr)) {
              /**
               * Payload specified an indexed attribute. Use index
               * to potentially decrease amount of accessed rows.
               */
              if (index.hasOwnProperty(payload[attr])) {
                accessedIndexes.push(index[payload[attr]]);
                indexAttrs.push(attr);
              }
            }
          });
          /**
           * Calculate set of unique PK values corresponding to each
           * foreign key's attribute value. Then retrieve all those rows.
           */

          if (accessedIndexes.length) {
            var lastIndex = accessedIndexes.pop();
            var indexedIds = accessedIndexes.reduce(function (result, index) {
              var indexSet = new Set(index);
              return result.filter(Set.prototype.has, indexSet);
            }, lastIndex);

            var _remainingPayload = Object.keys(payload).reduce(function (withoutIndexAttrs, filterAttr) {
              if (!indexAttrs.includes(filterAttr)) {
                withoutIndexAttrs[filterAttr] = payload[filterAttr];
              }

              return withoutIndexAttrs;
            }, {});

            if (Object.keys(_remainingPayload).length) {
              /**
               * Payload has additional, non-indexed columns.
               * Filter indexed rows by remaining payload (if any were found).
               */
              return reducer(_this2.accessIds(branch, indexedIds), objectSpread({}, clause, {
                payload: _remainingPayload
              }));
            }
            /**
             * No need to filter these rows any further.
             * The used indexes satisfy this clause's conditions.
             */


            return _this2.accessIds(branch, indexedIds);
          }
        } // Give up optimization: Retrieve all rows (full table scan).


        return reducer(_this2.accessList(branch), clause);
      }

      switch (type) {
        case FILTER:
          {
            return filter_1(rows, payload);
          }

        case EXCLUDE:
          {
            return reject_1(rows, payload);
          }

        case ORDER_BY:
          {
            var _payload = slicedToArray(payload, 2),
                iteratees = _payload[0],
                orders = _payload[1];

            return orderBy_1(rows, iteratees, orders);
          }

        default:
          return rows;
      }
    };

    return optimallyOrderedClauses.reduce(reducer, undefined);
  }
  /**
   * Returns the data structure including a new object `entry`
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object} entry - the object to insert
   * @return {Object} an object with two keys: `state` and `created`.
   *                  `state` is the new table state and `created` is the
   *                  row that was created.
   */
  ;

  _proto.insert = function insert(tx, branch, entry) {
    var _ops$batch$merge3;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;
    var hasId = entry.hasOwnProperty(this.idAttribute);
    var workingState = branch; // This will not affect string id's.

    var _idSequencer = idSequencer(this.getMaxId(branch), entry[this.idAttribute]),
        _idSequencer2 = slicedToArray(_idSequencer, 2),
        newMaxId = _idSequencer2[0],
        id = _idSequencer2[1];

    workingState = this.setMaxId(tx, branch, newMaxId);
    var finalEntry = hasId ? entry : ops.batch.set(batchToken, this.idAttribute, id, entry);
    var indexesToAppendTo = Object.keys(workingState.indexes).reduce(function (values, fkAttr) {
      if (!entry.hasOwnProperty(fkAttr)) return values;
      if (entry[fkAttr] === null) return values;
      values.push([fkAttr, entry[fkAttr]]);
      return values;
    }, []);

    if (withMutations) {
      ops.mutable.push(id, workingState[this.arrName]);
      ops.mutable.set(id, finalEntry, workingState[this.mapName]); // add id to indexes

      indexesToAppendTo.forEach(function (_ref3) {
        var _ref4 = slicedToArray(_ref3, 2),
            attr = _ref4[0],
            value = _ref4[1];

        var attrIndex = workingState.indexes[attr];

        if (attrIndex.hasOwnProperty(value)) {
          ops.mutable.push(id, attrIndex[value]);
        } else {
          ops.mutable.set(value, [id], attrIndex);
        }
      });
      return {
        state: workingState,
        created: finalEntry
      };
    }

    var nextIndexes = ops.batch.merge(batchToken, indexesToAppendTo.reduce(function (indexMap, _ref5) {
      var _ref6 = slicedToArray(_ref5, 2),
          attr = _ref6[0],
          value = _ref6[1];

      indexMap[attr] = ops.batch.merge(batchToken, defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);
      return indexMap;
    }, objectSpread({}, workingState.indexes)), workingState.indexes);
    var nextState = ops.batch.merge(batchToken, (_ops$batch$merge3 = {}, defineProperty(_ops$batch$merge3, this.arrName, ops.batch.push(batchToken, id, workingState[this.arrName])), defineProperty(_ops$batch$merge3, this.mapName, ops.batch.merge(batchToken, defineProperty({}, id, finalEntry), workingState[this.mapName])), defineProperty(_ops$batch$merge3, "indexes", nextIndexes), _ops$batch$merge3), workingState);
    return {
      state: nextState,
      created: finalEntry
    };
  }
  /**
   * Returns the data structure with objects where `rows`
   * are merged with `mergeObj`.
   *
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object[]} rows - rows to update
   * @param  {Object} mergeObj - The object to merge with each row.
   * @return {Object}
   */
  ;

  _proto.update = function update(tx, branch, rows, mergeObj) {
    var _this3 = this,
        _ops$batch$merge6;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;

    var mergeObjInto = function mergeObjInto(row) {
      var merge = withMutations ? ops.mutable.merge : ops.batch.merge(batchToken);
      return merge(mergeObj, row);
    };

    var set = withMutations ? ops.mutable.set : ops.batch.set(batchToken);
    var indexedAttrs = Object.keys(branch.indexes).filter(function (attr) {
      return mergeObj.hasOwnProperty(attr);
    });
    var indexIdsToAdd = [];
    var indexIdsToDelete = [];
    var nextMap = rows.reduce(function (map, row) {
      var prevAttrValues = indexedAttrs.reduce(function (valueMap, attr) {
        return objectSpread({}, valueMap, defineProperty({}, attr, row[attr]));
      }, {});
      var result = mergeObjInto(row);
      var nextAttrValues = indexedAttrs.reduce(function (valueMap, attr) {
        return objectSpread({}, valueMap, defineProperty({}, attr, result[attr]));
      }, {});
      var id = result[_this3.idAttribute];
      var nextRow = set(id, result, map);
      indexedAttrs.forEach(function (attr) {
        var prevValue = prevAttrValues[attr];
        var nextValue = nextAttrValues[attr];

        if (prevValue === nextValue) {
          // attribute has not changed, no need to update any index
          return;
        }

        if (prevValue !== null) {
          // remove id from attribute's index for its old value
          indexIdsToDelete.push([attr, prevValue, id]);
        }

        if (nextValue !== null) {
          // add id to attribute's index for its new value
          indexIdsToAdd.push([attr, nextValue, id]);
        }
      });
      return nextRow;
    }, branch[this.mapName]);
    var nextIndexes = branch.indexes;

    if (withMutations) {
      indexIdsToDelete.forEach(function (_ref7) {
        var _ref8 = slicedToArray(_ref7, 3),
            attr = _ref8[0],
            value = _ref8[1],
            id = _ref8[2];

        var arr = nextIndexes[attr][value];
        var idx = arr.indexOf(id);

        if (idx !== -1) {
          ops.mutable.splice(idx, 1, [], arr);
        }
      });
      indexIdsToAdd.forEach(function (_ref9) {
        var _ref10 = slicedToArray(_ref9, 3),
            attr = _ref10[0],
            value = _ref10[1],
            id = _ref10[2];

        ops.mutable.push(id, nextIndexes[attr][value]);
      });
    } else {
      if (indexIdsToAdd.length) {
        nextIndexes = ops.batch.merge(batchToken, indexIdsToAdd.reduce(function (indexMap, _ref11) {
          var _ref12 = slicedToArray(_ref11, 3),
              attr = _ref12[0],
              value = _ref12[1],
              id = _ref12[2];

          indexMap[attr] = ops.batch.merge(batchToken, defineProperty({}, value, ops.batch.push(batchToken, id, indexMap[attr][value] || [])), indexMap[attr]);
          return indexMap;
        }, objectSpread({}, nextIndexes)), nextIndexes);
      }

      if (indexIdsToDelete.length) {
        nextIndexes = ops.batch.merge(batchToken, indexIdsToDelete.reduce(function (indexMap, _ref13) {
          var _ref14 = slicedToArray(_ref13, 3),
              attr = _ref14[0],
              value = _ref14[1],
              id = _ref14[2];

          indexMap[attr] = ops.batch.merge(batchToken, defineProperty({}, value, ops.batch.filter(batchToken, function (rowId) {
            return rowId !== id;
          }, indexMap[attr][value] || [])), indexMap[attr]);
          return indexMap;
        }, objectSpread({}, nextIndexes)), nextIndexes);
      }
    }

    return ops.batch.merge(batchToken, (_ops$batch$merge6 = {}, defineProperty(_ops$batch$merge6, this.mapName, nextMap), defineProperty(_ops$batch$merge6, "indexes", nextIndexes), _ops$batch$merge6), branch);
  }
  /**
   * Returns the data structure without rows `rows`.
   * @param  {Object} tx - transaction info
   * @param  {Object} branch - the data structure state
   * @param  {Object[]} rows - rows to update
   * @return {Object} the data structure without ids in `idsToDelete`.
   */
  ;

  _proto.delete = function _delete(tx, branch, rows) {
    var _this4 = this,
        _ops$batch$merge7;

    var batchToken = tx.batchToken,
        withMutations = tx.withMutations;
    var arrName = this.arrName,
        mapName = this.mapName;
    var arr = branch[arrName];
    var idsToDelete = rows.map(function (row) {
      return row[_this4.idAttribute];
    });

    if (withMutations) {
      idsToDelete.forEach(function (id) {
        var idx = arr.indexOf(id);

        if (idx !== -1) {
          ops.mutable.splice(idx, 1, [], arr);
        }

        ops.mutable.omit(id, branch[mapName]);
      }); // delete ids from all indexes

      Object.values(branch.indexes).forEach(function (attrIndex) {
        return Object.values(attrIndex).forEach(function (valueIndex) {
          return idsToDelete.forEach(function (id) {
            var idx = valueIndex.indexOf(id);

            if (idx !== -1) {
              ops.mutable.splice(idx, 1, [], valueIndex);
            }
          });
        });
      });
      return branch;
    }

    var nextIndexes = ops.batch.merge(batchToken, Object.entries(branch.indexes).reduce(function (indexMap, _ref15) {
      var _ref16 = slicedToArray(_ref15, 2),
          attr = _ref16[0],
          attrIndex = _ref16[1];

      indexMap[attr] = ops.batch.merge(batchToken, Object.entries(attrIndex).reduce(function (attrIndexMap, _ref17) {
        var _ref18 = slicedToArray(_ref17, 2),
            value = _ref18[0],
            valueIndex = _ref18[1];

        attrIndexMap[value] = ops.batch.filter(batchToken, function (id) {
          return !idsToDelete.includes(id);
        }, valueIndex);
        return attrIndexMap;
      }, objectSpread({}, indexMap[attr])), indexMap[attr]);
      return indexMap;
    }, objectSpread({}, branch.indexes)), branch.indexes);
    return ops.batch.merge(batchToken, (_ops$batch$merge7 = {}, defineProperty(_ops$batch$merge7, arrName, ops.batch.filter(batchToken, function (id) {
      return !idsToDelete.includes(id);
    }, branch[arrName])), defineProperty(_ops$batch$merge7, mapName, ops.batch.omit(batchToken, idsToDelete, branch[mapName])), defineProperty(_ops$batch$merge7, "indexes", ops.batch.merge(batchToken, nextIndexes, branch.indexes)), _ops$batch$merge7), branch);
  };

  return Table;
}();

function replaceTableState(tableName, newTableState, tx, state) {
  var batchToken = tx.batchToken,
      withMutations = tx.withMutations;

  if (withMutations) {
    state[tableName] = newTableState;
    return state;
  }

  return ops.batch.set(batchToken, tableName, newTableState, state);
}

function query(tables, querySpec, state) {
  var tableName = querySpec.table,
      clauses = querySpec.clauses;
  var table = tables[tableName];
  var rows = table.query(state[tableName], clauses);
  return {
    rows: rows
  };
}

function update(tables, updateSpec, tx, state) {
  var action = updateSpec.action,
      payload = updateSpec.payload;
  var tableName;
  var nextTableState;
  var resultPayload;

  if (action === CREATE) {
    tableName = updateSpec.table;
    var table = tables[tableName];
    var currTableState = state[tableName];
    var result = table.insert(tx, currTableState, payload);
    nextTableState = result.state;
    resultPayload = result.created;
  } else {
    var querySpec = updateSpec.query;
    tableName = querySpec.table;

    var _query = query(tables, querySpec, state),
        rows = _query.rows;

    var _table = tables[tableName];
    var _currTableState = state[tableName];

    if (action === UPDATE) {
      nextTableState = _table.update(tx, _currTableState, rows, payload); // return updated rows

      resultPayload = query(tables, querySpec, state).rows;
    } else if (action === DELETE) {
      nextTableState = _table.delete(tx, _currTableState, rows); // return original rows that we just deleted

      resultPayload = rows;
    } else {
      throw new Error("Database received unknown update type: ".concat(action));
    }
  }

  var nextDBState = replaceTableState(tableName, nextTableState, tx, state);
  return {
    status: SUCCESS,
    state: nextDBState,
    payload: resultPayload
  };
}

function createDatabase(schemaSpec) {
  var tableSpecs = schemaSpec.tables;
  var tables = Object.entries(tableSpecs).reduce(function (map, _ref) {
    var _ref2 = slicedToArray(_ref, 2),
        tableName = _ref2[0],
        tableSpec = _ref2[1];

    return objectSpread({}, map, defineProperty({}, tableName, new Table(tableSpec)));
  }, {});

  var getEmptyState = function getEmptyState() {
    return Object.entries(tables).reduce(function (map, _ref3) {
      var _ref4 = slicedToArray(_ref3, 2),
          tableName = _ref4[0],
          table = _ref4[1];

      return objectSpread({}, map, defineProperty({}, tableName, table.getEmptyState()));
    }, {});
  };

  return {
    getEmptyState: getEmptyState,
    query: query.bind(null, tables),
    update: update.bind(null, tables),
    // Used to inspect the schema.
    describe: function describe(tableName) {
      return tables[tableName];
    }
  };
}

var lib = createCommonjsModule(function (module, exports) {

exports.__esModule = true;
exports.defaultMemoize = defaultMemoize;
exports.createSelectorCreator = createSelectorCreator;
exports.createStructuredSelector = createStructuredSelector;
function defaultEqualityCheck(a, b) {
  return a === b;
}

function areArgumentsShallowlyEqual(equalityCheck, prev, next) {
  if (prev === null || next === null || prev.length !== next.length) {
    return false;
  }

  // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.
  var length = prev.length;
  for (var i = 0; i < length; i++) {
    if (!equalityCheck(prev[i], next[i])) {
      return false;
    }
  }

  return true;
}

function defaultMemoize(func) {
  var equalityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;

  var lastArgs = null;
  var lastResult = null;
  // we reference arguments instead of spreading them for performance reasons
  return function () {
    if (!areArgumentsShallowlyEqual(equalityCheck, lastArgs, arguments)) {
      // apply arguments instead of spreading for performance.
      lastResult = func.apply(null, arguments);
    }

    lastArgs = arguments;
    return lastResult;
  };
}

function getDependencies(funcs) {
  var dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;

  if (!dependencies.every(function (dep) {
    return typeof dep === 'function';
  })) {
    var dependencyTypes = dependencies.map(function (dep) {
      return typeof dep;
    }).join(', ');
    throw new Error('Selector creators expect all input-selectors to be functions, ' + ('instead received the following types: [' + dependencyTypes + ']'));
  }

  return dependencies;
}

function createSelectorCreator(memoize) {
  for (var _len = arguments.length, memoizeOptions = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    memoizeOptions[_key - 1] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, funcs = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      funcs[_key2] = arguments[_key2];
    }

    var recomputations = 0;
    var resultFunc = funcs.pop();
    var dependencies = getDependencies(funcs);

    var memoizedResultFunc = memoize.apply(undefined, [function () {
      recomputations++;
      // apply arguments instead of spreading for performance.
      return resultFunc.apply(null, arguments);
    }].concat(memoizeOptions));

    // If a selector is called with the exact same arguments we don't need to traverse our dependencies again.
    var selector = defaultMemoize(function () {
      var params = [];
      var length = dependencies.length;

      for (var i = 0; i < length; i++) {
        // apply arguments instead of spreading and mutate a local list of params for performance.
        params.push(dependencies[i].apply(null, arguments));
      }

      // apply arguments instead of spreading for performance.
      return memoizedResultFunc.apply(null, params);
    });

    selector.resultFunc = resultFunc;
    selector.recomputations = function () {
      return recomputations;
    };
    selector.resetRecomputations = function () {
      return recomputations = 0;
    };
    return selector;
  };
}

var createSelector = exports.createSelector = createSelectorCreator(defaultMemoize);

function createStructuredSelector(selectors) {
  var selectorCreator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : createSelector;

  if (typeof selectors !== 'object') {
    throw new Error('createStructuredSelector expects first argument to be an object ' + ('where each property is a selector, instead received a ' + typeof selectors));
  }
  var objectKeys = Object.keys(selectors);
  return selectorCreator(objectKeys.map(function (key) {
    return selectors[key];
  }), function () {
    for (var _len3 = arguments.length, values = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      values[_key3] = arguments[_key3];
    }

    return values.reduce(function (composition, value, index) {
      composition[objectKeys[index]] = value;
      return composition;
    }, {});
  });
}
});

unwrapExports(lib);
var lib_1 = lib.defaultMemoize;
var lib_2 = lib.createSelectorCreator;
var lib_3 = lib.createStructuredSelector;
var lib_4 = lib.createSelector;

var defaultEqualityCheck = function defaultEqualityCheck(a, b) {
  return a === b;
};

var argsAreEqual = function argsAreEqual(lastArgs, nextArgs, equalityCheck) {
  return nextArgs.every(function (arg, index) {
    return equalityCheck(arg, lastArgs[index]);
  });
};

var rowsAreEqual = function rowsAreEqual(ids, rowsA, rowsB) {
  return ids.every(function (id) {
    return rowsA[id] === rowsB[id];
  });
};

var accessedModelInstancesAreEqual = function accessedModelInstancesAreEqual(previous, ormState, orm) {
  var accessedInstances = previous.accessedInstances;
  return Object.entries(accessedInstances).every(function (_ref) {
    var _ref2 = slicedToArray(_ref, 2),
        modelName = _ref2[0],
        instances = _ref2[1];

    // if the entire table has not been changed, we have nothing to do
    if (previous.ormState[modelName] === ormState[modelName]) {
      return true;
    }

    var _orm$getDatabase$desc = orm.getDatabase().describe(modelName),
        mapName = _orm$getDatabase$desc.mapName;

    var previousRows = previous.ormState[modelName][mapName];
    var rows = ormState[modelName][mapName];
    var accessedIds = Object.keys(instances);
    return rowsAreEqual(accessedIds, previousRows, rows);
  });
};

var accessedIndexesAreEqual = function accessedIndexesAreEqual(previous, ormState) {
  var accessedIndexes = previous.accessedIndexes;
  return Object.entries(accessedIndexes).every(function (_ref3) {
    var _ref4 = slicedToArray(_ref3, 2),
        modelName = _ref4[0],
        indexes = _ref4[1];

    return Object.entries(indexes).every(function (_ref5) {
      var _ref6 = slicedToArray(_ref5, 2),
          column = _ref6[0],
          values = _ref6[1];

      return values.every(function (value) {
        return previous.ormState[modelName].indexes[column][value] === ormState[modelName].indexes[column][value];
      });
    });
  });
};

var fullTableScannedModelsAreEqual = function fullTableScannedModelsAreEqual(previous, ormState) {
  return previous.fullTableScannedModels.every(function (modelName) {
    return previous.ormState[modelName] === ormState[modelName];
  });
};
/**
 * A memoizer to use with redux-orm
 * selectors. When the memoized function is first run,
 * the memoizer will remember the models that are accessed
 * during that function run.
 *
 * On subsequent runs, the memoizer will check if those
 * models' states have changed compared to the previous run.
 *
 * Memoization algorithm operates like this:
 *
 * 1. Has the selector been run before? If not, go to 6.
 *
 * 2. If the selector has other input selectors in addition to the
 *    ORM state selector, check their results for equality with the previous results.
 *    If they aren't equal, go to 6.
 *
 * 3. Some filter queries may have required scanning entire tables during the last run.
 *    If any of those tables have changed, go to 6.
 *
 * 4. Check which foreign key indexes the database has used to speed up queries
 *    during the last run. If any have changed, go to 6.
 *
 * 5. Check which Model's instances the selector has accessed during the last run.
 *    Check for equality with each of those states versus their states in the
 *    previous ORM state. If all of them are equal, return the previous result.
 *
 * 6. Run the selector. Check the Session object used by the selector for
 *    which Model's states were accessed, and merge them with the previously
 *    saved information about accessed models (if-else branching can change
 *    which models are accessed on different inputs). Save the ORM state and
 *    other arguments the selector was called with, overriding previously
 *    saved values. Save the selector result. Return the selector result.
 *
 * @private
 * @param  {Function} func - function to memoize
 * @param  {Function} argEqualityCheck - equality check function to use with normal
 *                                       selector args
 * @param  {ORM} orm - a redux-orm ORM instance
 * @return {Function} `func` memoized.
 */


function memoize$1(func) {
  var argEqualityCheck = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultEqualityCheck;
  var orm = arguments.length > 2 ? arguments[2] : undefined;
  var previous = {
    /* Result of the previous function call */
    result: null,

    /* Arguments to the previous function call (excluding ORM state) */
    args: null,

    /**
     * Snapshot of the previous database.
     *
     * Lets us know how the tables looked like
     * during the previous function call.
     */
    ormState: null,

    /**
     * Names of models whose tables have been scanned completely
     * during previous function call (contains only model names)
     * Format example: ['Book']
     */
    fullTableScannedModels: [],

    /**
     * Map of which model instances have been accessed
     * during previous function call.
     * Contains only PKs of accessed instances.
     * Format example: { Book: { 1: true, 3: true } }
     */
    accessedInstances: {},

    /**
     * Map of which attribute indexes have been accessed
     * during previous function call.
     * Contains only attributes that were actually filtered on.
     * Author.withId(3).books would add 3 to the authorId index below.
     * Format example: { Book: { authorId: [1, 2], publisherId: [5] } }
     */
    accessedIndexes: {}
  };
  return function () {
    for (var _len = arguments.length, stateAndArgs = new Array(_len), _key = 0; _key < _len; _key++) {
      stateAndArgs[_key] = arguments[_key];
    }

    /**
     * The first argument to this function needs to be
     * the ORM's reducer state in the user's Redux store.
     */
    var ormState = stateAndArgs[0],
        args = stateAndArgs.slice(1);
    var selectorWasCalledBefore = previous.args && previous.ormState;

    if (selectorWasCalledBefore && argsAreEqual(previous.args, args, argEqualityCheck) && fullTableScannedModelsAreEqual(previous, ormState) && accessedIndexesAreEqual(previous, ormState) && accessedModelInstancesAreEqual(previous, ormState, orm)) {
      /**
       * None of this selector's dependencies have changed
       * since the last time that we called it.
       */
      return previous.result;
    }
    /**
     * Start a session so that the selector can access the database.
     * Make this session immutable. This way we can find out if
     * the operations that the selector performs are cacheable.
     */


    var session = orm.session(ormState);
    /* This is where we call the actual function */

    var result = func.apply(void 0, [session].concat(toConsumableArray(args)));
    /**
     * The metadata for the previous call are no longer valid.
     * Update cached values.
     */

    previous = {
      /* Arguments that were passed to the selector */
      args: args,

      /* Selector result */
      result: result,

      /* Redux state slice for session.state */
      ormState: ormState,

      /* Rows retrieved by resolved primary key */
      accessedInstances: session.accessedModelInstances,

      /* Foreign key indexes that were used to speed up queries */
      accessedIndexes: session.accessedIndexes,

      /* Tables that had to be scanned completely */
      fullTableScannedModels: session.fullTableScannedModels
    };
    return result;
  };
}

/**
 * @module redux
 */

/**
 * Calls all models' reducers if they exist.
 * @return {undefined}
 */

function defaultUpdater(session, action) {
  session.sessionBoundModels.forEach(function (modelClass) {
    if (typeof modelClass.reducer === 'function') {
      // This calls this.applyUpdate to update this.state
      modelClass.reducer(action, modelClass, session);
    }
  });
}
/**
 * Call the returned function to pass actions to Redux-ORM.
 *
 * @global
 *
 * @param {ORM} orm - the ORM instance.
 * @param {Function} [updater] - the function updating the ORM state based on the given action.
 * @return {Function} reducer that will update the ORM state.
 */

function createReducer(orm) {
  var updater = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultUpdater;
  return function (state, action) {
    var session = orm.session(state || orm.getEmptyState());
    updater(session, action);
    return session.state;
  };
}
/**
 * Returns a memoized selector based on passed arguments.
 * This is similar to `reselect`'s `createSelector`,
 * except you can also pass a single function to be memoized.
 *
 * If you pass multiple functions, the format will be the
 * same as in `reselect`. The last argument is the selector
 * function and the previous are input selectors.
 *
 * When you use this method to create a selector, the returned selector
 * expects the whole `redux-orm` state branch as input. In the selector
 * function that you pass as the last argument, you will receive a
 * `session` argument (a `Session` instance) followed by any
 * input arguments, like in `reselect`.
 *
 * This is an example selector:
 *
 * ```javascript
 * // orm is an instance of ORM
 * const bookSelector = createSelector(orm, session => {
 *     return session.Book.map(book => {
 *         return Object.assign({}, book.ref, {
 *             authors: book.authors.map(author => author.name),
 *             genres: book.genres.map(genre => genre.name),
 *         });
 *     });
 * });
 * ```
 *
 * redux-orm uses a special memoization function to avoid recomputations.
 *
 * Everytime a selector runs, this function records which instances
 * of your `Model`s were accessed.<br>
 * On subsequent runs, the selector first checks if the previously
 * accessed instances or `args` have changed in any way:
 * <ul>
 *     <li>If yes, the selector calls the function you passed to it.</li>
 *     <li>If not, it just returns the previous result
 *         (unless you call it for the first time).</li>
 * </ul>
 *
 * This way you can use the `PureRenderMixin` in your React components
 * for performance gains.
 *
 * @global
 *
 * @param {ORM} orm - the ORM instance
 * @param  {...Function} args - zero or more input selectors
 *                              and the selector function.
 * @return {Function} memoized selector
 */

function createSelector(orm) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  if (args.length === 1) {
    return memoize$1(args[0], undefined, orm);
  }

  return lib_2(memoize$1, undefined, orm).apply(void 0, args);
}

var ORM_DEFAULTS = {
  createDatabase: createDatabase
};
var RESERVED_TABLE_OPTIONS = ['indexes', 'meta'];

var isReservedTableOption = function isReservedTableOption(word) {
  return RESERVED_TABLE_OPTIONS.includes(word);
};
/**
 * ORM - the Object Relational Mapper.
 *
 * Use instances of this class to:
 *
 * - Register your {@link Model} classes using {@link ORM#register}
 * - Get the empty state for the underlying database with {@link ORM#getEmptyState}
 * - Start an immutable database session with {@link ORM#session}
 * - Start a mutating database session with {@link ORM#mutableSession}
 *
 * Internally, this class handles generating a schema specification from models
 * to the database.
 */


var ORM =
/*#__PURE__*/
function () {
  /**
   * Creates a new ORM instance.
   */
  function ORM(opts) {
    var _Object$assign = Object.assign({}, ORM_DEFAULTS, opts || {}),
        createDatabase = _Object$assign.createDatabase;

    this.createDatabase = createDatabase;
    this.registry = [];
    this.implicitThroughModels = [];
    this.installedFields = {};
  }
  /**
   * Registers a {@link Model} class to the ORM.
   *
   * If the model has declared any ManyToMany fields, their
   * through models will be generated and registered with
   * this call, unless a custom through model has been specified.
   *
   * @param  {...Model} model - a {@link Model} class to register
   * @return {undefined}
   */


  var _proto = ORM.prototype;

  _proto.register = function register() {
    var _this = this;

    for (var _len = arguments.length, models = new Array(_len), _key = 0; _key < _len; _key++) {
      models[_key] = arguments[_key];
    }

    models.forEach(function (model) {
      if (model.modelName === undefined) {
        throw new Error('A model was passed that doesn\'t have a modelName set');
      }

      model.invalidateClassCache();

      _this.registerManyToManyModelsFor(model);

      _this.registry.push(model);
    });
  };

  _proto.registerManyToManyModelsFor = function registerManyToManyModelsFor(model) {
    var _this2 = this;

    var fields = model.fields;
    var thisModelName = model.modelName;
    Object.entries(fields).forEach(function (_ref) {
      var _ref2 = slicedToArray(_ref, 2),
          fieldName = _ref2[0],
          fieldInstance = _ref2[1];

      if (!(fieldInstance instanceof ManyToMany)) {
        return;
      }

      var toModelName;

      if (fieldInstance.toModelName === 'this') {
        toModelName = thisModelName;
      } else {
        toModelName = fieldInstance.toModelName; // eslint-disable-line prefer-destructuring
      }

      var selfReferencing = thisModelName === toModelName;
      var fromFieldName = m2mFromFieldName(thisModelName);
      var toFieldName = m2mToFieldName(toModelName);

      if (fieldInstance.through) {
        if (selfReferencing && !fieldInstance.throughFields) {
          throw new Error('Self-referencing many-to-many relationship at ' + "\"".concat(thisModelName, ".").concat(fieldName, "\" using custom ") + "model \"".concat(fieldInstance.through, "\" has no ") + 'throughFields key. Cannot determine which ' + 'fields reference the instances partaking ' + 'in the relationship.');
        }
      } else {
        var _Through$fields;

        var Through =
        /*#__PURE__*/
        function (_Model) {
          inheritsLoose(ThroughModel, _Model);

          function ThroughModel() {
            return _Model.apply(this, arguments) || this;
          }

          return ThroughModel;
        }(Model);

        Through.modelName = m2mName(thisModelName, fieldName);

        var PlainForeignKey =
        /*#__PURE__*/
        function (_ForeignKey) {
          inheritsLoose(ThroughForeignKeyField, _ForeignKey);

          function ThroughForeignKeyField() {
            return _ForeignKey.apply(this, arguments) || this;
          }

          createClass(ThroughForeignKeyField, [{
            key: "installsBackwardsVirtualField",
            get: function get() {
              return false;
            }
          }, {
            key: "installsBackwardsDescriptor",
            get: function get() {
              return false;
            }
          }]);

          return ThroughForeignKeyField;
        }(ForeignKey);

        var ForeignKeyClass = selfReferencing ? PlainForeignKey : ForeignKey;
        Through.fields = (_Through$fields = {
          id: attr()
        }, defineProperty(_Through$fields, fromFieldName, new ForeignKeyClass(thisModelName)), defineProperty(_Through$fields, toFieldName, new ForeignKeyClass(toModelName)), _Through$fields);
        Through.invalidateClassCache();

        _this2.implicitThroughModels.push(Through);
      }
    });
  }
  /**
   * Gets a {@link Model} class by its name from the registry.
   * @param  {string} modelName - the name of the {@link Model} class to get
   * @throws If {@link Model} class is not found.
   * @return {Model} the {@link Model} class, if found
   */
  ;

  _proto.get = function get(modelName) {
    var allModels = this.registry.concat(this.implicitThroughModels);
    var found = Object.values(allModels).find(function (model) {
      return model.modelName === modelName;
    });

    if (typeof found === 'undefined') {
      throw new Error("Did not find model ".concat(modelName, " from registry."));
    }

    return found;
  };

  _proto.getModelClasses = function getModelClasses() {
    this._setupModelPrototypes(this.registry);

    this._setupModelPrototypes(this.implicitThroughModels);

    return this.registry.concat(this.implicitThroughModels);
  };

  _proto.generateSchemaSpec = function generateSchemaSpec() {
    var models = this.getModelClasses();
    var tables = models.reduce(function (spec, modelClass) {
      var tableName = modelClass.modelName;

      var tableSpec = modelClass._getTableOpts(); // eslint-disable-line no-underscore-dangle


      Object.keys(tableSpec).forEach(function (key) {
        if (!isReservedTableOption(key)) return;
        throw new Error("Reserved keyword `".concat(key, "` used in ").concat(tableName, ".options."));
      });
      spec[tableName] = Object.assign({}, {
        fields: modelClass.fields
      }, tableSpec);
      return spec;
    }, {});
    return {
      tables: tables
    };
  };

  _proto.getDatabase = function getDatabase() {
    if (!this.db) {
      this.db = this.createDatabase(this.generateSchemaSpec());
    }

    return this.db;
  }
  /**
   * Returns the empty database state.
   * @return {Object} the empty state
   */
  ;

  _proto.getEmptyState = function getEmptyState() {
    return this.getDatabase().getEmptyState();
  }
  /**
   * Begins an immutable database session.
   *
   * @param  {Object} state  - the state the database manages
   * @return {Session} a new {@link Session} instance
   */
  ;

  _proto.session = function session(state) {
    return new Session(this, this.getDatabase(), state);
  }
  /**
   * Begins a mutable database session.
   *
   * @param  {Object} state  - the state the database manages
   * @return {Session} a new {@link Session} instance
   */
  ;

  _proto.mutableSession = function mutableSession(state) {
    return new Session(this, this.getDatabase(), state, true);
  }
  /**
   * @private
   */
  ;

  _proto._setupModelPrototypes = function _setupModelPrototypes(models) {
    var _this3 = this;

    models.forEach(function (model) {
      if (!model.isSetUp) {
        var fields = model.fields,
            modelName = model.modelName,
            querySetClass = model.querySetClass;
        Object.entries(fields).forEach(function (_ref3) {
          var _ref4 = slicedToArray(_ref3, 2),
              fieldName = _ref4[0],
              field = _ref4[1];

          if (!_this3._isFieldInstalled(modelName, fieldName)) {
            _this3._installField(field, fieldName, model);

            _this3._setFieldInstalled(modelName, fieldName);
          }
        });
        attachQuerySetMethods(model, querySetClass);
        model.isSetUp = true;
      }
    });
  }
  /**
   * @private
   */
  ;

  _proto._isFieldInstalled = function _isFieldInstalled(modelName, fieldName) {
    return this.installedFields.hasOwnProperty(modelName) ? !!this.installedFields[modelName][fieldName] : false;
  }
  /**
   * @private
   */
  ;

  _proto._setFieldInstalled = function _setFieldInstalled(modelName, fieldName) {
    if (!this.installedFields.hasOwnProperty(modelName)) {
      this.installedFields[modelName] = {};
    }

    this.installedFields[modelName][fieldName] = true;
  }
  /**
   * Installs a field on a model and its related models if necessary.
   * @private
   */
  ;

  _proto._installField = function _installField(field, fieldName, model) {
    var FieldInstaller = field.installerClass;
    new FieldInstaller({
      field: field,
      fieldName: fieldName,
      model: model,
      orm: this
    }).run();
  } // DEPRECATED AND REMOVED METHODS

  /**
   * @deprecated Use {@link ORM#mutableSession} instead.
   */
  ;

  _proto.withMutations = function withMutations(state) {
    warnDeprecated('`ORM.prototype.withMutations` has been deprecated. ' + 'Use `ORM.prototype.mutableSession` instead.');
    return this.mutableSession(state);
  }
  /**
   * @deprecated Use {@link ORM#session} instead.
   */
  ;

  _proto.from = function from(state) {
    warnDeprecated('`ORM.prototype.from` has been deprecated. ' + 'Use `ORM.prototype.session` instead.');
    return this.session(state);
  }
  /**
   * @deprecated Access {@link Session#state} instead.
   */
  ;

  _proto.reducer = function reducer() {
    warnDeprecated('`ORM.prototype.reducer` has been deprecated. Access ' + 'the `Session.prototype.state` property instead.');
    return createReducer(this);
  }
  /**
   * @deprecated Use `import { createSelector } from "redux-orm"` instead.
   */
  ;

  _proto.createSelector = function createSelector$1() {
    warnDeprecated('`ORM.prototype.createSelector` has been deprecated. ' + 'Import `createSelector` from Redux-ORM instead.');

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return createSelector.apply(void 0, [this].concat(args));
  }
  /**
   * @deprecated Use {@link ORM#getEmptyState} instead.
   */
  ;

  _proto.getDefaultState = function getDefaultState() {
    warnDeprecated('`ORM.prototype.getDefaultState` has been deprecated. Use ' + '`ORM.prototype.getEmptyState` instead.');
    return this.getEmptyState();
  }
  /**
   * @deprecated Define a Model class instead.
   */
  ;

  _proto.define = function define() {
    throw new Error('`ORM.prototype.define` has been removed. Please define a Model class.');
  };

  return ORM;
}();
function DeprecatedSchema() {
  throw new Error('Schema has been renamed to ORM. Please import ORM instead of Schema ' + 'from Redux-ORM.');
}

var Schema = DeprecatedSchema;

var Backend = function RemovedBackend() {
  throw new Error('Having a custom Backend instance is now unsupported. ' + 'Documentation for database customization is upcoming, for now ' + 'please look at the db folder in the source.');
};

exports.Attribute = Attribute;
exports.Backend = Backend;
exports.ForeignKey = ForeignKey;
exports.ManyToMany = ManyToMany;
exports.Model = Model;
exports.ORM = ORM;
exports.OneToOne = OneToOne;
exports.QuerySet = QuerySet;
exports.Schema = Schema;
exports.Session = Session;
exports.attr = attr;
exports.createReducer = createReducer;
exports.createSelector = createSelector;
exports.default = Model;
exports.fk = fk;
exports.many = many;
exports.oneToOne = oneToOne;

Object.defineProperty(exports, '__esModule', { value: true });

});
